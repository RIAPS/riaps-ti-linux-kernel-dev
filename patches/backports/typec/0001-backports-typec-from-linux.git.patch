From 7d0bd2a4f6d635a5a066b845fdecc6642ebeabb0 Mon Sep 17 00:00:00 2001
From: Robert Nelson <robertcnelson@gmail.com>
Date: Wed, 16 Oct 2019 14:15:36 -0500
Subject: [PATCH] backports: typec: from: linux.git

Reference: v4.16.18
Signed-off-by: Robert Nelson <robertcnelson@gmail.com>
---
 drivers/staging/typec/Kconfig                 |  24 -
 drivers/staging/typec/Makefile                |   3 -
 drivers/staging/typec/TODO                    |  15 -
 drivers/staging/typec/fusb302/TODO            |  10 -
 drivers/staging/typec/tcpci.c                 | 526 ---------------
 drivers/staging/typec/tcpci.h                 | 133 ----
 drivers/usb/typec/Kconfig                     |  73 ++-
 drivers/usb/typec/Makefile                    |   4 +
 .../{staging => usb}/typec/fusb302/Kconfig    |   0
 .../{staging => usb}/typec/fusb302/Makefile   |   1 +
 .../{staging => usb}/typec/fusb302/fusb302.c  |  34 +-
 .../typec/fusb302/fusb302_reg.h               |  11 +-
 drivers/{staging => usb}/typec/tcpm.c         | 193 ++++--
 drivers/usb/typec/tps6598x.c                  | 504 ++++++++++++++
 drivers/usb/typec/typec.c                     |   5 +-
 drivers/usb/typec/typec_wcove.c               | 619 +++++++++++++-----
 drivers/usb/typec/ucsi/Kconfig                |   1 -
 drivers/usb/typec/ucsi/trace.c                |   1 +
 drivers/usb/typec/ucsi/ucsi.c                 |  18 +-
 drivers/usb/typec/ucsi/ucsi_acpi.c            |  10 +-
 .../staging/typec => include/linux/usb}/pd.h  |   7 +
 .../typec => include/linux/usb}/pd_bdo.h      |   0
 .../typec => include/linux/usb}/pd_vdo.h      |   2 +-
 .../typec => include/linux/usb}/tcpm.h        |  73 ++-
 24 files changed, 1258 insertions(+), 1009 deletions(-)
 delete mode 100644 drivers/staging/typec/Kconfig
 delete mode 100644 drivers/staging/typec/Makefile
 delete mode 100644 drivers/staging/typec/TODO
 delete mode 100644 drivers/staging/typec/fusb302/TODO
 delete mode 100644 drivers/staging/typec/tcpci.c
 delete mode 100644 drivers/staging/typec/tcpci.h
 rename drivers/{staging => usb}/typec/fusb302/Kconfig (100%)
 rename drivers/{staging => usb}/typec/fusb302/Makefile (53%)
 rename drivers/{staging => usb}/typec/fusb302/fusb302.c (98%)
 rename drivers/{staging => usb}/typec/fusb302/fusb302_reg.h (93%)
 rename drivers/{staging => usb}/typec/tcpm.c (96%)
 create mode 100644 drivers/usb/typec/tps6598x.c
 rename {drivers/staging/typec => include/linux/usb}/pd.h (98%)
 rename {drivers/staging/typec => include/linux/usb}/pd_bdo.h (100%)
 rename {drivers/staging/typec => include/linux/usb}/pd_vdo.h (99%)
 rename {drivers/staging/typec => include/linux/usb}/tcpm.h (63%)

diff --git a/drivers/staging/typec/Kconfig b/drivers/staging/typec/Kconfig
deleted file mode 100644
index 37a0781b0d0c..000000000000
--- a/drivers/staging/typec/Kconfig
+++ /dev/null
@@ -1,24 +0,0 @@
-menu "USB Power Delivery and Type-C drivers"
-
-config TYPEC_TCPM
-	tristate "USB Type-C Port Controller Manager"
-	depends on USB
-	select TYPEC
-	help
-	  The Type-C Port Controller Manager provides a USB PD and USB Type-C
-	  state machine for use with Type-C Port Controllers.
-
-if TYPEC_TCPM
-
-config TYPEC_TCPCI
-	tristate "Type-C Port Controller Interface driver"
-	depends on I2C
-	select REGMAP_I2C
-	help
-	  Type-C Port Controller driver for TCPCI-compliant controller.
-
-source "drivers/staging/typec/fusb302/Kconfig"
-
-endif
-
-endmenu
diff --git a/drivers/staging/typec/Makefile b/drivers/staging/typec/Makefile
deleted file mode 100644
index 30a7e29cbc9e..000000000000
--- a/drivers/staging/typec/Makefile
+++ /dev/null
@@ -1,3 +0,0 @@
-obj-$(CONFIG_TYPEC_TCPM)	+= tcpm.o
-obj-$(CONFIG_TYPEC_TCPCI)	+= tcpci.o
-obj-y				+= fusb302/
diff --git a/drivers/staging/typec/TODO b/drivers/staging/typec/TODO
deleted file mode 100644
index bc1f97a2d1bf..000000000000
--- a/drivers/staging/typec/TODO
+++ /dev/null
@@ -1,15 +0,0 @@
-tcpm:
-- Add documentation (at the very least for the API to low level drivers)
-- Split PD code into separate file
-- Check if it makes sense to use tracepoints instead of debugfs for debug logs
-- Implement Alternate Mode handling
-- Address "#if 0" code if not addressed with the above
-- Validate all comments marked with "XXX"; either address or remove comments
-- Add support for USB PD 3.0. While not mandatory, at least fast role swap
-  as well as authentication support would be very desirable.
-
-tcpci:
-- Test with real hardware
-
-Please send patches to Guenter Roeck <linux@roeck-us.net> and copy
-Heikki Krogerus <heikki.krogerus@linux.intel.com>.
diff --git a/drivers/staging/typec/fusb302/TODO b/drivers/staging/typec/fusb302/TODO
deleted file mode 100644
index 19b466eb585d..000000000000
--- a/drivers/staging/typec/fusb302/TODO
+++ /dev/null
@@ -1,10 +0,0 @@
-fusb302:
-- Find a better logging scheme, at least not having the same debugging/logging
-  code replicated here and in tcpm
-- Find a non-hacky way to coordinate between PM and I2C access
-- Documentation? The FUSB302 datasheet provides information on the chip to help
-  understand the code. But it may still be helpful to have a documentation.
-- We may want to replace the  "fcs,max-snk-microvolt", "fcs,max-snk-microamp",
-  "fcs,max-snk-microwatt" and "fcs,operating-snk-microwatt" device(tree)
-  properties with properties which are part of a generic type-c controller
-  devicetree binding.
diff --git a/drivers/staging/typec/tcpci.c b/drivers/staging/typec/tcpci.c
deleted file mode 100644
index df72d8b01e73..000000000000
--- a/drivers/staging/typec/tcpci.c
+++ /dev/null
@@ -1,526 +0,0 @@
-/*
- * Copyright 2015-2017 Google, Inc
- *
- * This program is free software; you can redistribute it and/or modify
- * it under the terms of the GNU General Public License as published by
- * the Free Software Foundation; either version 2 of the License, or
- * (at your option) any later version.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- * GNU General Public License for more details.
- *
- * USB Type-C Port Controller Interface.
- */
-
-#include <linux/delay.h>
-#include <linux/kernel.h>
-#include <linux/module.h>
-#include <linux/i2c.h>
-#include <linux/interrupt.h>
-#include <linux/regmap.h>
-#include <linux/usb/typec.h>
-
-#include "pd.h"
-#include "tcpci.h"
-#include "tcpm.h"
-
-#define PD_RETRY_COUNT 3
-
-struct tcpci {
-	struct device *dev;
-	struct i2c_client *client;
-
-	struct tcpm_port *port;
-
-	struct regmap *regmap;
-
-	bool controls_vbus;
-
-	struct tcpc_dev tcpc;
-};
-
-static inline struct tcpci *tcpc_to_tcpci(struct tcpc_dev *tcpc)
-{
-	return container_of(tcpc, struct tcpci, tcpc);
-}
-
-static int tcpci_read16(struct tcpci *tcpci, unsigned int reg,
-			unsigned int *val)
-{
-	return regmap_raw_read(tcpci->regmap, reg, val, sizeof(u16));
-}
-
-static int tcpci_write16(struct tcpci *tcpci, unsigned int reg, u16 val)
-{
-	return regmap_raw_write(tcpci->regmap, reg, &val, sizeof(u16));
-}
-
-static int tcpci_set_cc(struct tcpc_dev *tcpc, enum typec_cc_status cc)
-{
-	struct tcpci *tcpci = tcpc_to_tcpci(tcpc);
-	unsigned int reg;
-	int ret;
-
-	switch (cc) {
-	case TYPEC_CC_RA:
-		reg = (TCPC_ROLE_CTRL_CC_RA << TCPC_ROLE_CTRL_CC1_SHIFT) |
-			(TCPC_ROLE_CTRL_CC_RA << TCPC_ROLE_CTRL_CC2_SHIFT);
-		break;
-	case TYPEC_CC_RD:
-		reg = (TCPC_ROLE_CTRL_CC_RD << TCPC_ROLE_CTRL_CC1_SHIFT) |
-			(TCPC_ROLE_CTRL_CC_RD << TCPC_ROLE_CTRL_CC2_SHIFT);
-		break;
-	case TYPEC_CC_RP_DEF:
-		reg = (TCPC_ROLE_CTRL_CC_RP << TCPC_ROLE_CTRL_CC1_SHIFT) |
-			(TCPC_ROLE_CTRL_CC_RP << TCPC_ROLE_CTRL_CC2_SHIFT) |
-			(TCPC_ROLE_CTRL_RP_VAL_DEF <<
-			 TCPC_ROLE_CTRL_RP_VAL_SHIFT);
-		break;
-	case TYPEC_CC_RP_1_5:
-		reg = (TCPC_ROLE_CTRL_CC_RP << TCPC_ROLE_CTRL_CC1_SHIFT) |
-			(TCPC_ROLE_CTRL_CC_RP << TCPC_ROLE_CTRL_CC2_SHIFT) |
-			(TCPC_ROLE_CTRL_RP_VAL_1_5 <<
-			 TCPC_ROLE_CTRL_RP_VAL_SHIFT);
-		break;
-	case TYPEC_CC_RP_3_0:
-		reg = (TCPC_ROLE_CTRL_CC_RP << TCPC_ROLE_CTRL_CC1_SHIFT) |
-			(TCPC_ROLE_CTRL_CC_RP << TCPC_ROLE_CTRL_CC2_SHIFT) |
-			(TCPC_ROLE_CTRL_RP_VAL_3_0 <<
-			 TCPC_ROLE_CTRL_RP_VAL_SHIFT);
-		break;
-	case TYPEC_CC_OPEN:
-	default:
-		reg = (TCPC_ROLE_CTRL_CC_OPEN << TCPC_ROLE_CTRL_CC1_SHIFT) |
-			(TCPC_ROLE_CTRL_CC_OPEN << TCPC_ROLE_CTRL_CC2_SHIFT);
-		break;
-	}
-
-	ret = regmap_write(tcpci->regmap, TCPC_ROLE_CTRL, reg);
-	if (ret < 0)
-		return ret;
-
-	return 0;
-}
-
-static int tcpci_start_drp_toggling(struct tcpc_dev *tcpc,
-				    enum typec_cc_status cc)
-{
-	struct tcpci *tcpci = tcpc_to_tcpci(tcpc);
-	unsigned int reg = TCPC_ROLE_CTRL_DRP;
-
-	switch (cc) {
-	default:
-	case TYPEC_CC_RP_DEF:
-		reg |= (TCPC_ROLE_CTRL_RP_VAL_DEF <<
-			TCPC_ROLE_CTRL_RP_VAL_SHIFT);
-		break;
-	case TYPEC_CC_RP_1_5:
-		reg |= (TCPC_ROLE_CTRL_RP_VAL_1_5 <<
-			TCPC_ROLE_CTRL_RP_VAL_SHIFT);
-		break;
-	case TYPEC_CC_RP_3_0:
-		reg |= (TCPC_ROLE_CTRL_RP_VAL_3_0 <<
-			TCPC_ROLE_CTRL_RP_VAL_SHIFT);
-		break;
-	}
-
-	return regmap_write(tcpci->regmap, TCPC_ROLE_CTRL, reg);
-}
-
-static enum typec_cc_status tcpci_to_typec_cc(unsigned int cc, bool sink)
-{
-	switch (cc) {
-	case 0x1:
-		return sink ? TYPEC_CC_RP_DEF : TYPEC_CC_RA;
-	case 0x2:
-		return sink ? TYPEC_CC_RP_1_5 : TYPEC_CC_RD;
-	case 0x3:
-		if (sink)
-			return TYPEC_CC_RP_3_0;
-	case 0x0:
-	default:
-		return TYPEC_CC_OPEN;
-	}
-}
-
-static int tcpci_get_cc(struct tcpc_dev *tcpc,
-			enum typec_cc_status *cc1, enum typec_cc_status *cc2)
-{
-	struct tcpci *tcpci = tcpc_to_tcpci(tcpc);
-	unsigned int reg;
-	int ret;
-
-	ret = regmap_read(tcpci->regmap, TCPC_CC_STATUS, &reg);
-	if (ret < 0)
-		return ret;
-
-	*cc1 = tcpci_to_typec_cc((reg >> TCPC_CC_STATUS_CC1_SHIFT) &
-				 TCPC_CC_STATUS_CC1_MASK,
-				 reg & TCPC_CC_STATUS_TERM);
-	*cc2 = tcpci_to_typec_cc((reg >> TCPC_CC_STATUS_CC2_SHIFT) &
-				 TCPC_CC_STATUS_CC2_MASK,
-				 reg & TCPC_CC_STATUS_TERM);
-
-	return 0;
-}
-
-static int tcpci_set_polarity(struct tcpc_dev *tcpc,
-			      enum typec_cc_polarity polarity)
-{
-	struct tcpci *tcpci = tcpc_to_tcpci(tcpc);
-	int ret;
-
-	ret = regmap_write(tcpci->regmap, TCPC_TCPC_CTRL,
-			   (polarity == TYPEC_POLARITY_CC2) ?
-			   TCPC_TCPC_CTRL_ORIENTATION : 0);
-	if (ret < 0)
-		return ret;
-
-	return 0;
-}
-
-static int tcpci_set_vconn(struct tcpc_dev *tcpc, bool enable)
-{
-	struct tcpci *tcpci = tcpc_to_tcpci(tcpc);
-	int ret;
-
-	ret = regmap_write(tcpci->regmap, TCPC_POWER_CTRL,
-			   enable ? TCPC_POWER_CTRL_VCONN_ENABLE : 0);
-	if (ret < 0)
-		return ret;
-
-	return 0;
-}
-
-static int tcpci_set_roles(struct tcpc_dev *tcpc, bool attached,
-			   enum typec_role role, enum typec_data_role data)
-{
-	struct tcpci *tcpci = tcpc_to_tcpci(tcpc);
-	unsigned int reg;
-	int ret;
-
-	reg = PD_REV20 << TCPC_MSG_HDR_INFO_REV_SHIFT;
-	if (role == TYPEC_SOURCE)
-		reg |= TCPC_MSG_HDR_INFO_PWR_ROLE;
-	if (data == TYPEC_HOST)
-		reg |= TCPC_MSG_HDR_INFO_DATA_ROLE;
-	ret = regmap_write(tcpci->regmap, TCPC_MSG_HDR_INFO, reg);
-	if (ret < 0)
-		return ret;
-
-	return 0;
-}
-
-static int tcpci_set_pd_rx(struct tcpc_dev *tcpc, bool enable)
-{
-	struct tcpci *tcpci = tcpc_to_tcpci(tcpc);
-	unsigned int reg = 0;
-	int ret;
-
-	if (enable)
-		reg = TCPC_RX_DETECT_SOP | TCPC_RX_DETECT_HARD_RESET;
-	ret = regmap_write(tcpci->regmap, TCPC_RX_DETECT, reg);
-	if (ret < 0)
-		return ret;
-
-	return 0;
-}
-
-static int tcpci_get_vbus(struct tcpc_dev *tcpc)
-{
-	struct tcpci *tcpci = tcpc_to_tcpci(tcpc);
-	unsigned int reg;
-	int ret;
-
-	ret = regmap_read(tcpci->regmap, TCPC_POWER_STATUS, &reg);
-	if (ret < 0)
-		return ret;
-
-	return !!(reg & TCPC_POWER_STATUS_VBUS_PRES);
-}
-
-static int tcpci_set_vbus(struct tcpc_dev *tcpc, bool source, bool sink)
-{
-	struct tcpci *tcpci = tcpc_to_tcpci(tcpc);
-	int ret;
-
-	/* Disable both source and sink first before enabling anything */
-
-	if (!source) {
-		ret = regmap_write(tcpci->regmap, TCPC_COMMAND,
-				   TCPC_CMD_DISABLE_SRC_VBUS);
-		if (ret < 0)
-			return ret;
-	}
-
-	if (!sink) {
-		ret = regmap_write(tcpci->regmap, TCPC_COMMAND,
-				   TCPC_CMD_DISABLE_SINK_VBUS);
-		if (ret < 0)
-			return ret;
-	}
-
-	if (source) {
-		ret = regmap_write(tcpci->regmap, TCPC_COMMAND,
-				   TCPC_CMD_SRC_VBUS_DEFAULT);
-		if (ret < 0)
-			return ret;
-	}
-
-	if (sink) {
-		ret = regmap_write(tcpci->regmap, TCPC_COMMAND,
-				   TCPC_CMD_SINK_VBUS);
-		if (ret < 0)
-			return ret;
-	}
-
-	return 0;
-}
-
-static int tcpci_pd_transmit(struct tcpc_dev *tcpc,
-			     enum tcpm_transmit_type type,
-			     const struct pd_message *msg)
-{
-	struct tcpci *tcpci = tcpc_to_tcpci(tcpc);
-	unsigned int reg, cnt, header;
-	int ret;
-
-	cnt = msg ? pd_header_cnt(msg->header) * 4 : 0;
-	ret = regmap_write(tcpci->regmap, TCPC_TX_BYTE_CNT, cnt + 2);
-	if (ret < 0)
-		return ret;
-
-	header = msg ? msg->header : 0;
-	ret = tcpci_write16(tcpci, TCPC_TX_HDR, header);
-	if (ret < 0)
-		return ret;
-
-	if (cnt > 0) {
-		ret = regmap_raw_write(tcpci->regmap, TCPC_TX_DATA,
-				       &msg->payload, cnt);
-		if (ret < 0)
-			return ret;
-	}
-
-	reg = (PD_RETRY_COUNT << TCPC_TRANSMIT_RETRY_SHIFT) |
-		(type << TCPC_TRANSMIT_TYPE_SHIFT);
-	ret = regmap_write(tcpci->regmap, TCPC_TRANSMIT, reg);
-	if (ret < 0)
-		return ret;
-
-	return 0;
-}
-
-static int tcpci_init(struct tcpc_dev *tcpc)
-{
-	struct tcpci *tcpci = tcpc_to_tcpci(tcpc);
-	unsigned long timeout = jiffies + msecs_to_jiffies(2000); /* XXX */
-	unsigned int reg;
-	int ret;
-
-	while (time_before_eq(jiffies, timeout)) {
-		ret = regmap_read(tcpci->regmap, TCPC_POWER_STATUS, &reg);
-		if (ret < 0)
-			return ret;
-		if (!(reg & TCPC_POWER_STATUS_UNINIT))
-			break;
-		usleep_range(10000, 20000);
-	}
-	if (time_after(jiffies, timeout))
-		return -ETIMEDOUT;
-
-	/* Clear all events */
-	ret = tcpci_write16(tcpci, TCPC_ALERT, 0xffff);
-	if (ret < 0)
-		return ret;
-
-	if (tcpci->controls_vbus)
-		reg = TCPC_POWER_STATUS_VBUS_PRES;
-	else
-		reg = 0;
-	ret = regmap_write(tcpci->regmap, TCPC_POWER_STATUS_MASK, reg);
-	if (ret < 0)
-		return ret;
-
-	reg = TCPC_ALERT_TX_SUCCESS | TCPC_ALERT_TX_FAILED |
-		TCPC_ALERT_TX_DISCARDED | TCPC_ALERT_RX_STATUS |
-		TCPC_ALERT_RX_HARD_RST | TCPC_ALERT_CC_STATUS;
-	if (tcpci->controls_vbus)
-		reg |= TCPC_ALERT_POWER_STATUS;
-	return tcpci_write16(tcpci, TCPC_ALERT_MASK, reg);
-}
-
-static irqreturn_t tcpci_irq(int irq, void *dev_id)
-{
-	struct tcpci *tcpci = dev_id;
-	unsigned int status, reg;
-
-	tcpci_read16(tcpci, TCPC_ALERT, &status);
-
-	/*
-	 * Clear alert status for everything except RX_STATUS, which shouldn't
-	 * be cleared until we have successfully retrieved message.
-	 */
-	if (status & ~TCPC_ALERT_RX_STATUS)
-		tcpci_write16(tcpci, TCPC_ALERT,
-			      status & ~TCPC_ALERT_RX_STATUS);
-
-	if (status & TCPC_ALERT_CC_STATUS)
-		tcpm_cc_change(tcpci->port);
-
-	if (status & TCPC_ALERT_POWER_STATUS) {
-		regmap_read(tcpci->regmap, TCPC_POWER_STATUS_MASK, &reg);
-
-		/*
-		 * If power status mask has been reset, then the TCPC
-		 * has reset.
-		 */
-		if (reg == 0xff)
-			tcpm_tcpc_reset(tcpci->port);
-		else
-			tcpm_vbus_change(tcpci->port);
-	}
-
-	if (status & TCPC_ALERT_RX_STATUS) {
-		struct pd_message msg;
-		unsigned int cnt;
-
-		regmap_read(tcpci->regmap, TCPC_RX_BYTE_CNT, &cnt);
-
-		tcpci_read16(tcpci, TCPC_RX_HDR, &reg);
-		msg.header = reg;
-
-		if (WARN_ON(cnt > sizeof(msg.payload)))
-			cnt = sizeof(msg.payload);
-
-		if (cnt > 0)
-			regmap_raw_read(tcpci->regmap, TCPC_RX_DATA,
-					&msg.payload, cnt);
-
-		/* Read complete, clear RX status alert bit */
-		tcpci_write16(tcpci, TCPC_ALERT, TCPC_ALERT_RX_STATUS);
-
-		tcpm_pd_receive(tcpci->port, &msg);
-	}
-
-	if (status & TCPC_ALERT_RX_HARD_RST)
-		tcpm_pd_hard_reset(tcpci->port);
-
-	if (status & TCPC_ALERT_TX_SUCCESS)
-		tcpm_pd_transmit_complete(tcpci->port, TCPC_TX_SUCCESS);
-	else if (status & TCPC_ALERT_TX_DISCARDED)
-		tcpm_pd_transmit_complete(tcpci->port, TCPC_TX_DISCARDED);
-	else if (status & TCPC_ALERT_TX_FAILED)
-		tcpm_pd_transmit_complete(tcpci->port, TCPC_TX_FAILED);
-
-	return IRQ_HANDLED;
-}
-
-static const struct regmap_config tcpci_regmap_config = {
-	.reg_bits = 8,
-	.val_bits = 8,
-
-	.max_register = 0x7F, /* 0x80 .. 0xFF are vendor defined */
-};
-
-static const struct tcpc_config tcpci_tcpc_config = {
-	.type = TYPEC_PORT_DFP,
-	.default_role = TYPEC_SINK,
-};
-
-static int tcpci_parse_config(struct tcpci *tcpci)
-{
-	tcpci->controls_vbus = true; /* XXX */
-
-	/* TODO: Populate struct tcpc_config from ACPI/device-tree */
-	tcpci->tcpc.config = &tcpci_tcpc_config;
-
-	return 0;
-}
-
-static int tcpci_probe(struct i2c_client *client,
-		       const struct i2c_device_id *i2c_id)
-{
-	struct tcpci *tcpci;
-	int err;
-
-	tcpci = devm_kzalloc(&client->dev, sizeof(*tcpci), GFP_KERNEL);
-	if (!tcpci)
-		return -ENOMEM;
-
-	tcpci->client = client;
-	tcpci->dev = &client->dev;
-	i2c_set_clientdata(client, tcpci);
-	tcpci->regmap = devm_regmap_init_i2c(client, &tcpci_regmap_config);
-	if (IS_ERR(tcpci->regmap))
-		return PTR_ERR(tcpci->regmap);
-
-	tcpci->tcpc.init = tcpci_init;
-	tcpci->tcpc.get_vbus = tcpci_get_vbus;
-	tcpci->tcpc.set_vbus = tcpci_set_vbus;
-	tcpci->tcpc.set_cc = tcpci_set_cc;
-	tcpci->tcpc.get_cc = tcpci_get_cc;
-	tcpci->tcpc.set_polarity = tcpci_set_polarity;
-	tcpci->tcpc.set_vconn = tcpci_set_vconn;
-	tcpci->tcpc.start_drp_toggling = tcpci_start_drp_toggling;
-
-	tcpci->tcpc.set_pd_rx = tcpci_set_pd_rx;
-	tcpci->tcpc.set_roles = tcpci_set_roles;
-	tcpci->tcpc.pd_transmit = tcpci_pd_transmit;
-
-	err = tcpci_parse_config(tcpci);
-	if (err < 0)
-		return err;
-
-	/* Disable chip interrupts */
-	tcpci_write16(tcpci, TCPC_ALERT_MASK, 0);
-
-	err = devm_request_threaded_irq(tcpci->dev, client->irq, NULL,
-					tcpci_irq,
-					IRQF_ONESHOT | IRQF_TRIGGER_LOW,
-					dev_name(tcpci->dev), tcpci);
-	if (err < 0)
-		return err;
-
-	tcpci->port = tcpm_register_port(tcpci->dev, &tcpci->tcpc);
-	return PTR_ERR_OR_ZERO(tcpci->port);
-}
-
-static int tcpci_remove(struct i2c_client *client)
-{
-	struct tcpci *tcpci = i2c_get_clientdata(client);
-
-	tcpm_unregister_port(tcpci->port);
-
-	return 0;
-}
-
-static const struct i2c_device_id tcpci_id[] = {
-	{ "tcpci", 0 },
-	{ }
-};
-MODULE_DEVICE_TABLE(i2c, tcpci_id);
-
-#ifdef CONFIG_OF
-static const struct of_device_id tcpci_of_match[] = {
-	{ .compatible = "usb,tcpci", },
-	{},
-};
-MODULE_DEVICE_TABLE(of, tcpci_of_match);
-#endif
-
-static struct i2c_driver tcpci_i2c_driver = {
-	.driver = {
-		.name = "tcpci",
-		.of_match_table = of_match_ptr(tcpci_of_match),
-	},
-	.probe = tcpci_probe,
-	.remove = tcpci_remove,
-	.id_table = tcpci_id,
-};
-module_i2c_driver(tcpci_i2c_driver);
-
-MODULE_DESCRIPTION("USB Type-C Port Controller Interface driver");
-MODULE_LICENSE("GPL");
diff --git a/drivers/staging/typec/tcpci.h b/drivers/staging/typec/tcpci.h
deleted file mode 100644
index 10b04c8723da..000000000000
--- a/drivers/staging/typec/tcpci.h
+++ /dev/null
@@ -1,133 +0,0 @@
-/*
- * Copyright 2015-2017 Google, Inc
- *
- * This program is free software; you can redistribute it and/or modify
- * it under the terms of the GNU General Public License as published by
- * the Free Software Foundation; either version 2 of the License, or
- * (at your option) any later version.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- * GNU General Public License for more details.
- *
- * USB Type-C Port Controller Interface.
- */
-
-#ifndef __LINUX_USB_TCPCI_H
-#define __LINUX_USB_TCPCI_H
-
-#define TCPC_VENDOR_ID			0x0
-#define TCPC_PRODUCT_ID			0x2
-#define TCPC_BCD_DEV			0x4
-#define TCPC_TC_REV			0x6
-#define TCPC_PD_REV			0x8
-#define TCPC_PD_INT_REV			0xa
-
-#define TCPC_ALERT			0x10
-#define TCPC_ALERT_VBUS_DISCNCT		BIT(11)
-#define TCPC_ALERT_RX_BUF_OVF		BIT(10)
-#define TCPC_ALERT_FAULT		BIT(9)
-#define TCPC_ALERT_V_ALARM_LO		BIT(8)
-#define TCPC_ALERT_V_ALARM_HI		BIT(7)
-#define TCPC_ALERT_TX_SUCCESS		BIT(6)
-#define TCPC_ALERT_TX_DISCARDED		BIT(5)
-#define TCPC_ALERT_TX_FAILED		BIT(4)
-#define TCPC_ALERT_RX_HARD_RST		BIT(3)
-#define TCPC_ALERT_RX_STATUS		BIT(2)
-#define TCPC_ALERT_POWER_STATUS		BIT(1)
-#define TCPC_ALERT_CC_STATUS		BIT(0)
-
-#define TCPC_ALERT_MASK			0x12
-#define TCPC_POWER_STATUS_MASK		0x14
-#define TCPC_FAULT_STATUS_MASK		0x15
-#define TCPC_CONFIG_STD_OUTPUT		0x18
-
-#define TCPC_TCPC_CTRL			0x19
-#define TCPC_TCPC_CTRL_ORIENTATION	BIT(0)
-
-#define TCPC_ROLE_CTRL			0x1a
-#define TCPC_ROLE_CTRL_DRP		BIT(6)
-#define TCPC_ROLE_CTRL_RP_VAL_SHIFT	4
-#define TCPC_ROLE_CTRL_RP_VAL_MASK	0x3
-#define TCPC_ROLE_CTRL_RP_VAL_DEF	0x0
-#define TCPC_ROLE_CTRL_RP_VAL_1_5	0x1
-#define TCPC_ROLE_CTRL_RP_VAL_3_0	0x2
-#define TCPC_ROLE_CTRL_CC2_SHIFT	2
-#define TCPC_ROLE_CTRL_CC2_MASK		0x3
-#define TCPC_ROLE_CTRL_CC1_SHIFT	0
-#define TCPC_ROLE_CTRL_CC1_MASK		0x3
-#define TCPC_ROLE_CTRL_CC_RA		0x0
-#define TCPC_ROLE_CTRL_CC_RP		0x1
-#define TCPC_ROLE_CTRL_CC_RD		0x2
-#define TCPC_ROLE_CTRL_CC_OPEN		0x3
-
-#define TCPC_FAULT_CTRL			0x1b
-
-#define TCPC_POWER_CTRL			0x1c
-#define TCPC_POWER_CTRL_VCONN_ENABLE	BIT(0)
-
-#define TCPC_CC_STATUS			0x1d
-#define TCPC_CC_STATUS_TERM		BIT(4)
-#define TCPC_CC_STATUS_CC2_SHIFT	2
-#define TCPC_CC_STATUS_CC2_MASK		0x3
-#define TCPC_CC_STATUS_CC1_SHIFT	0
-#define TCPC_CC_STATUS_CC1_MASK		0x3
-
-#define TCPC_POWER_STATUS		0x1e
-#define TCPC_POWER_STATUS_UNINIT	BIT(6)
-#define TCPC_POWER_STATUS_VBUS_DET	BIT(3)
-#define TCPC_POWER_STATUS_VBUS_PRES	BIT(2)
-
-#define TCPC_FAULT_STATUS		0x1f
-
-#define TCPC_COMMAND			0x23
-#define TCPC_CMD_WAKE_I2C		0x11
-#define TCPC_CMD_DISABLE_VBUS_DETECT	0x22
-#define TCPC_CMD_ENABLE_VBUS_DETECT	0x33
-#define TCPC_CMD_DISABLE_SINK_VBUS	0x44
-#define TCPC_CMD_SINK_VBUS		0x55
-#define TCPC_CMD_DISABLE_SRC_VBUS	0x66
-#define TCPC_CMD_SRC_VBUS_DEFAULT	0x77
-#define TCPC_CMD_SRC_VBUS_HIGH		0x88
-#define TCPC_CMD_LOOK4CONNECTION	0x99
-#define TCPC_CMD_RXONEMORE		0xAA
-#define TCPC_CMD_I2C_IDLE		0xFF
-
-#define TCPC_DEV_CAP_1			0x24
-#define TCPC_DEV_CAP_2			0x26
-#define TCPC_STD_INPUT_CAP		0x28
-#define TCPC_STD_OUTPUT_CAP		0x29
-
-#define TCPC_MSG_HDR_INFO		0x2e
-#define TCPC_MSG_HDR_INFO_DATA_ROLE	BIT(3)
-#define TCPC_MSG_HDR_INFO_PWR_ROLE	BIT(0)
-#define TCPC_MSG_HDR_INFO_REV_SHIFT	1
-#define TCPC_MSG_HDR_INFO_REV_MASK	0x3
-
-#define TCPC_RX_DETECT			0x2f
-#define TCPC_RX_DETECT_HARD_RESET	BIT(5)
-#define TCPC_RX_DETECT_SOP		BIT(0)
-
-#define TCPC_RX_BYTE_CNT		0x30
-#define TCPC_RX_BUF_FRAME_TYPE		0x31
-#define TCPC_RX_HDR			0x32
-#define TCPC_RX_DATA			0x34 /* through 0x4f */
-
-#define TCPC_TRANSMIT			0x50
-#define TCPC_TRANSMIT_RETRY_SHIFT	4
-#define TCPC_TRANSMIT_RETRY_MASK	0x3
-#define TCPC_TRANSMIT_TYPE_SHIFT	0
-#define TCPC_TRANSMIT_TYPE_MASK		0x7
-
-#define TCPC_TX_BYTE_CNT		0x51
-#define TCPC_TX_HDR			0x52
-#define TCPC_TX_DATA			0x54 /* through 0x6f */
-
-#define TCPC_VBUS_VOLTAGE			0x70
-#define TCPC_VBUS_SINK_DISCONNECT_THRESH	0x72
-#define TCPC_VBUS_STOP_DISCHARGE_THRESH		0x74
-#define TCPC_VBUS_VOLTAGE_ALARM_HI_CFG		0x76
-#define TCPC_VBUS_VOLTAGE_ALARM_LO_CFG		0x78
-
-#endif /* __LINUX_USB_TCPCI_H */
diff --git a/drivers/usb/typec/Kconfig b/drivers/usb/typec/Kconfig
index bc1b7745f1d4..bcb2744c5977 100644
--- a/drivers/usb/typec/Kconfig
+++ b/drivers/usb/typec/Kconfig
@@ -1,8 +1,60 @@
 
-menu "USB Power Delivery and Type-C drivers"
+menuconfig TYPEC
+	tristate "USB Type-C Support"
+	help
+	  USB Type-C Specification defines a cable and connector for USB where
+	  only one type of plug is supported on both ends, i.e. there will not
+	  be Type-A plug on one end of the cable and Type-B plug on the other.
+	  Determination of the host-to-device relationship happens through a
+	  specific Configuration Channel (CC) which goes through the USB Type-C
+	  cable. The Configuration Channel may also be used to detect optional
+	  Accessory Modes - Analog Audio and Debug - and if USB Power Delivery
+	  is supported, the Alternate Modes, where the connector is used for
+	  something else then USB communication.
+
+	  USB Power Delivery Specification defines a protocol that can be used
+	  to negotiate the voltage and current levels with the connected
+	  partners. USB Power Delivery allows higher voltages then the normal
+	  5V, up to 20V, and current up to 5A over the cable. The USB Power
+	  Delivery protocol is also used to negotiate the optional Alternate
+	  Modes when they are supported. USB Power Delivery does not depend on
+	  USB Type-C connector, however it is mostly used together with USB
+	  Type-C connectors.
+
+	  USB Type-C and USB Power Delivery Specifications define a set of state
+	  machines that need to be implemented in either software or firmware.
+	  Simple USB Type-C PHYs, for example USB Type-C Port Controller
+	  Interface Specification compliant "Port Controllers" need the state
+	  machines to be handled in the OS, but stand-alone USB Type-C and Power
+	  Delivery controllers handle the state machines inside their firmware.
+	  The USB Type-C and Power Delivery controllers usually function
+	  autonomously, and do not necessarily require drivers.
+
+	  Enable this configurations option if you have USB Type-C connectors on
+	  your system and 1) you know your USB Type-C hardware requires OS
+	  control (a driver) to function, or 2) if you need to be able to read
+	  the status of the USB Type-C ports in your system, or 3) if you need
+	  to be able to swap the power role (decide are you supplying or
+	  consuming power over the cable) or data role (host or device) when
+	  both roles are supported.
 
-config TYPEC
-	tristate
+	  For more information, see the kernel documentation for USB Type-C
+	  Connector Class API (Documentation/driver-api/usb/typec.rst)
+	  <https://www.kernel.org/doc/html/latest/driver-api/usb/typec.html>
+	  and ABI (Documentation/ABI/testing/sysfs-class-typec).
+
+if TYPEC
+
+config TYPEC_TCPM
+	tristate "USB Type-C Port Controller Manager"
+	depends on USB
+	help
+	  The Type-C Port Controller Manager provides a USB PD and USB Type-C
+	  state machine for use with Type-C Port Controllers.
+
+if TYPEC_TCPM
+
+source "drivers/usb/typec/fusb302/Kconfig"
 
 config TYPEC_WCOVE
 	tristate "Intel WhiskeyCove PMIC USB Type-C PHY driver"
@@ -10,7 +62,6 @@ config TYPEC_WCOVE
 	depends on INTEL_SOC_PMIC
 	depends on INTEL_PMC_IPC
 	depends on BXT_WC_PMIC_OPREGION
-	select TYPEC
 	help
 	  This driver adds support for USB Type-C detection on Intel Broxton
 	  platforms that have Intel Whiskey Cove PMIC. The driver can detect the
@@ -19,6 +70,18 @@ config TYPEC_WCOVE
 	  To compile this driver as module, choose M here: the module will be
 	  called typec_wcove
 
+endif # TYPEC_TCPM
+
 source "drivers/usb/typec/ucsi/Kconfig"
 
-endmenu
+config TYPEC_TPS6598X
+	tristate "TI TPS6598x USB Power Delivery controller driver"
+	depends on I2C
+	help
+	  Say Y or M here if your system has TI TPS65982 or TPS65983 USB Power
+	  Delivery controller.
+
+	  If you choose to build this driver as a dynamically linked module, the
+	  module will be called tps6598x.ko.
+
+endif # TYPEC
diff --git a/drivers/usb/typec/Makefile b/drivers/usb/typec/Makefile
index bc214f15f1b5..bb3138a6eaac 100644
--- a/drivers/usb/typec/Makefile
+++ b/drivers/usb/typec/Makefile
@@ -1,3 +1,7 @@
+# SPDX-License-Identifier: GPL-2.0
 obj-$(CONFIG_TYPEC)		+= typec.o
+obj-$(CONFIG_TYPEC_TCPM)	+= tcpm.o
+obj-y				+= fusb302/
 obj-$(CONFIG_TYPEC_WCOVE)	+= typec_wcove.o
 obj-$(CONFIG_TYPEC_UCSI)	+= ucsi/
+obj-$(CONFIG_TYPEC_TPS6598X)	+= tps6598x.o
diff --git a/drivers/staging/typec/fusb302/Kconfig b/drivers/usb/typec/fusb302/Kconfig
similarity index 100%
rename from drivers/staging/typec/fusb302/Kconfig
rename to drivers/usb/typec/fusb302/Kconfig
diff --git a/drivers/staging/typec/fusb302/Makefile b/drivers/usb/typec/fusb302/Makefile
similarity index 53%
rename from drivers/staging/typec/fusb302/Makefile
rename to drivers/usb/typec/fusb302/Makefile
index 207efa5fbab8..3b51b33631a0 100644
--- a/drivers/staging/typec/fusb302/Makefile
+++ b/drivers/usb/typec/fusb302/Makefile
@@ -1 +1,2 @@
+# SPDX-License-Identifier: GPL-2.0
 obj-$(CONFIG_TYPEC_FUSB302)	+= fusb302.o
diff --git a/drivers/staging/typec/fusb302/fusb302.c b/drivers/usb/typec/fusb302/fusb302.c
similarity index 98%
rename from drivers/staging/typec/fusb302/fusb302.c
rename to drivers/usb/typec/fusb302/fusb302.c
index 7d9f25db1add..dcd8ef085b30 100644
--- a/drivers/staging/typec/fusb302/fusb302.c
+++ b/drivers/usb/typec/fusb302/fusb302.c
@@ -1,16 +1,7 @@
+// SPDX-License-Identifier: GPL-2.0+
 /*
  * Copyright 2016-2017 Google, Inc
  *
- * This program is free software; you can redistribute it and/or modify
- * it under the terms of the GNU General Public License as published by
- * the Free Software Foundation; either version 2 of the License, or
- * (at your option) any later version.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- * GNU General Public License for more details.
- *
  * Fairchild FUSB302 Type-C Chip Driver
  */
 
@@ -25,7 +16,6 @@
 #include <linux/module.h>
 #include <linux/mutex.h>
 #include <linux/of_device.h>
-#include <linux/of_device.h>
 #include <linux/of_gpio.h>
 #include <linux/pinctrl/consumer.h>
 #include <linux/power_supply.h>
@@ -37,11 +27,11 @@
 #include <linux/string.h>
 #include <linux/types.h>
 #include <linux/usb/typec.h>
+#include <linux/usb/tcpm.h>
+#include <linux/usb/pd.h>
 #include <linux/workqueue.h>
 
 #include "fusb302_reg.h"
-#include "../tcpm.h"
-#include "../pd.h"
 
 /*
  * When the device is SNK, BC_LVL interrupt is used to monitor cc pins
@@ -1753,24 +1743,24 @@ static int init_gpio(struct fusb302_chip *chip)
 	chip->gpio_int_n = of_get_named_gpio(node, "fcs,int_n", 0);
 	if (!gpio_is_valid(chip->gpio_int_n)) {
 		ret = chip->gpio_int_n;
-		fusb302_log(chip, "cannot get named GPIO Int_N, ret=%d", ret);
+		dev_err(chip->dev, "cannot get named GPIO Int_N, ret=%d", ret);
 		return ret;
 	}
 	ret = devm_gpio_request(chip->dev, chip->gpio_int_n, "fcs,int_n");
 	if (ret < 0) {
-		fusb302_log(chip, "cannot request GPIO Int_N, ret=%d", ret);
+		dev_err(chip->dev, "cannot request GPIO Int_N, ret=%d", ret);
 		return ret;
 	}
 	ret = gpio_direction_input(chip->gpio_int_n);
 	if (ret < 0) {
-		fusb302_log(chip,
-			    "cannot set GPIO Int_N to input, ret=%d", ret);
+		dev_err(chip->dev,
+			"cannot set GPIO Int_N to input, ret=%d", ret);
 		return ret;
 	}
 	ret = gpio_to_irq(chip->gpio_int_n);
 	if (ret < 0) {
-		fusb302_log(chip,
-			    "cannot request IRQ for GPIO Int_N, ret=%d", ret);
+		dev_err(chip->dev,
+			"cannot request IRQ for GPIO Int_N, ret=%d", ret);
 		return ret;
 	}
 	chip->gpio_int_n_irq = ret;
@@ -1867,7 +1857,8 @@ static int fusb302_probe(struct i2c_client *client,
 	chip->tcpm_port = tcpm_register_port(&client->dev, &chip->tcpc_dev);
 	if (IS_ERR(chip->tcpm_port)) {
 		ret = PTR_ERR(chip->tcpm_port);
-		fusb302_log(chip, "cannot register tcpm port, ret=%d", ret);
+		if (ret != -EPROBE_DEFER)
+			dev_err(dev, "cannot register tcpm port, ret=%d", ret);
 		goto destroy_workqueue;
 	}
 
@@ -1876,8 +1867,7 @@ static int fusb302_probe(struct i2c_client *client,
 					IRQF_ONESHOT | IRQF_TRIGGER_LOW,
 					"fsc_interrupt_int_n", chip);
 	if (ret < 0) {
-		fusb302_log(chip,
-			    "cannot request IRQ for GPIO Int_N, ret=%d", ret);
+		dev_err(dev, "cannot request IRQ for GPIO Int_N, ret=%d", ret);
 		goto tcpm_unregister_port;
 	}
 	enable_irq_wake(chip->gpio_int_n_irq);
diff --git a/drivers/staging/typec/fusb302/fusb302_reg.h b/drivers/usb/typec/fusb302/fusb302_reg.h
similarity index 93%
rename from drivers/staging/typec/fusb302/fusb302_reg.h
rename to drivers/usb/typec/fusb302/fusb302_reg.h
index 0682e63de773..00b39d365478 100644
--- a/drivers/staging/typec/fusb302/fusb302_reg.h
+++ b/drivers/usb/typec/fusb302/fusb302_reg.h
@@ -1,16 +1,7 @@
+// SPDX-License-Identifier: GPL-2.0+
 /*
  * Copyright 2016-2017 Google, Inc
  *
- * This program is free software; you can redistribute it and/or modify
- * it under the terms of the GNU General Public License as published by
- * the Free Software Foundation; either version 2 of the License, or
- * (at your option) any later version.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- * GNU General Public License for more details.
- *
  * Fairchild FUSB302 Type-C Chip Driver
  */
 
diff --git a/drivers/staging/typec/tcpm.c b/drivers/usb/typec/tcpm.c
similarity index 96%
rename from drivers/staging/typec/tcpm.c
rename to drivers/usb/typec/tcpm.c
index f237e31926f4..8b637a4b474b 100644
--- a/drivers/staging/typec/tcpm.c
+++ b/drivers/usb/typec/tcpm.c
@@ -1,16 +1,7 @@
+// SPDX-License-Identifier: GPL-2.0+
 /*
  * Copyright 2015-2017 Google, Inc
  *
- * This program is free software; you can redistribute it and/or modify
- * it under the terms of the GNU General Public License as published by
- * the Free Software Foundation; either version 2 of the License, or
- * (at your option) any later version.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- * GNU General Public License for more details.
- *
  * USB Power Delivery protocol stack.
  */
 
@@ -26,14 +17,13 @@
 #include <linux/seq_file.h>
 #include <linux/slab.h>
 #include <linux/spinlock.h>
+#include <linux/usb/pd.h>
+#include <linux/usb/pd_bdo.h>
+#include <linux/usb/pd_vdo.h>
+#include <linux/usb/tcpm.h>
 #include <linux/usb/typec.h>
 #include <linux/workqueue.h>
 
-#include "pd.h"
-#include "pd_vdo.h"
-#include "pd_bdo.h"
-#include "tcpm.h"
-
 #define FOREACH_STATE(S)			\
 	S(INVALID_STATE),			\
 	S(DRP_TOGGLING),			\
@@ -908,27 +898,6 @@ static void svdm_consume_identity(struct tcpm_port *port, const __le32 *payload,
 
 	memset(&port->mode_data, 0, sizeof(port->mode_data));
 
-#if 0 /* Not really a match */
-	switch (PD_IDH_PTYPE(vdo)) {
-	case IDH_PTYPE_UNDEF:
-		port->partner.type = TYPEC_PARTNER_NONE; /* no longer exists */
-		break;
-	case IDH_PTYPE_HUB:
-		break;
-	case IDH_PTYPE_PERIPH:
-		break;
-	case IDH_PTYPE_PCABLE:
-		break;
-	case IDH_PTYPE_ACABLE:
-		break;
-	case IDH_PTYPE_AMA:
-		port->partner.type = TYPEC_PARTNER_ALTMODE;
-		break;
-	default:
-		break;
-	}
-#endif
-
 	port->partner_ident.id_header = vdo;
 	port->partner_ident.cert_stat = le32_to_cpu(payload[VDO_INDEX_CSTAT]);
 	port->partner_ident.product = product;
@@ -1008,7 +977,7 @@ static void svdm_consume_modes(struct tcpm_port *port, const __le32 *payload,
 	}
 	port->partner_altmode[pmdata->altmodes] =
 		typec_partner_register_altmode(port->partner, paltmode);
-	if (port->partner_altmode[pmdata->altmodes] == NULL) {
+	if (!port->partner_altmode[pmdata->altmodes]) {
 		tcpm_log(port,
 			 "Failed to register alternate modes for SVID 0x%04x",
 			 paltmode->svid);
@@ -1103,11 +1072,7 @@ static int tcpm_pd_svdm(struct tcpm_port *port, const __le32 *payload, int cnt,
 				response[0] = VDO(svid, 1, CMD_DISCOVER_MODES);
 				rlen = 1;
 			} else {
-#if 0
-				response[0] = pd_dfp_enter_mode(port, 0, 0);
-				if (response[0])
-					rlen = 1;
-#endif
+				/* enter alternate mode if/when implemented */
 			}
 			break;
 		case CMD_ENTER_MODE:
@@ -1145,10 +1110,6 @@ static void tcpm_handle_vdm_request(struct tcpm_port *port,
 
 	if (PD_VDO_SVDM(p0))
 		rlen = tcpm_pd_svdm(port, payload, cnt, response);
-#if 0
-	else
-		rlen = tcpm_pd_custom_vdm(port, cnt, payload, response);
-#endif
 
 	if (rlen > 0) {
 		tcpm_queue_vdm(port, response[0], &response[1], rlen - 1);
@@ -1286,6 +1247,100 @@ static void vdm_state_machine_work(struct work_struct *work)
 	mutex_unlock(&port->lock);
 }
 
+enum pdo_err {
+	PDO_NO_ERR,
+	PDO_ERR_NO_VSAFE5V,
+	PDO_ERR_VSAFE5V_NOT_FIRST,
+	PDO_ERR_PDO_TYPE_NOT_IN_ORDER,
+	PDO_ERR_FIXED_NOT_SORTED,
+	PDO_ERR_VARIABLE_BATT_NOT_SORTED,
+	PDO_ERR_DUPE_PDO,
+};
+
+static const char * const pdo_err_msg[] = {
+	[PDO_ERR_NO_VSAFE5V] =
+	" err: source/sink caps should atleast have vSafe5V",
+	[PDO_ERR_VSAFE5V_NOT_FIRST] =
+	" err: vSafe5V Fixed Supply Object Shall always be the first object",
+	[PDO_ERR_PDO_TYPE_NOT_IN_ORDER] =
+	" err: PDOs should be in the following order: Fixed; Battery; Variable",
+	[PDO_ERR_FIXED_NOT_SORTED] =
+	" err: Fixed supply pdos should be in increasing order of their fixed voltage",
+	[PDO_ERR_VARIABLE_BATT_NOT_SORTED] =
+	" err: Variable/Battery supply pdos should be in increasing order of their minimum voltage",
+	[PDO_ERR_DUPE_PDO] =
+	" err: Variable/Batt supply pdos cannot have same min/max voltage",
+};
+
+static enum pdo_err tcpm_caps_err(struct tcpm_port *port, const u32 *pdo,
+				  unsigned int nr_pdo)
+{
+	unsigned int i;
+
+	/* Should at least contain vSafe5v */
+	if (nr_pdo < 1)
+		return PDO_ERR_NO_VSAFE5V;
+
+	/* The vSafe5V Fixed Supply Object Shall always be the first object */
+	if (pdo_type(pdo[0]) != PDO_TYPE_FIXED ||
+	    pdo_fixed_voltage(pdo[0]) != VSAFE5V)
+		return PDO_ERR_VSAFE5V_NOT_FIRST;
+
+	for (i = 1; i < nr_pdo; i++) {
+		if (pdo_type(pdo[i]) < pdo_type(pdo[i - 1])) {
+			return PDO_ERR_PDO_TYPE_NOT_IN_ORDER;
+		} else if (pdo_type(pdo[i]) == pdo_type(pdo[i - 1])) {
+			enum pd_pdo_type type = pdo_type(pdo[i]);
+
+			switch (type) {
+			/*
+			 * The remaining Fixed Supply Objects, if
+			 * present, shall be sent in voltage order;
+			 * lowest to highest.
+			 */
+			case PDO_TYPE_FIXED:
+				if (pdo_fixed_voltage(pdo[i]) <=
+				    pdo_fixed_voltage(pdo[i - 1]))
+					return PDO_ERR_FIXED_NOT_SORTED;
+				break;
+			/*
+			 * The Battery Supply Objects and Variable
+			 * supply, if present shall be sent in Minimum
+			 * Voltage order; lowest to highest.
+			 */
+			case PDO_TYPE_VAR:
+			case PDO_TYPE_BATT:
+				if (pdo_min_voltage(pdo[i]) <
+				    pdo_min_voltage(pdo[i - 1]))
+					return PDO_ERR_VARIABLE_BATT_NOT_SORTED;
+				else if ((pdo_min_voltage(pdo[i]) ==
+					  pdo_min_voltage(pdo[i - 1])) &&
+					 (pdo_max_voltage(pdo[i]) ==
+					  pdo_min_voltage(pdo[i - 1])))
+					return PDO_ERR_DUPE_PDO;
+				break;
+			default:
+				tcpm_log_force(port, " Unknown pdo type");
+			}
+		}
+	}
+
+	return PDO_NO_ERR;
+}
+
+static int tcpm_validate_caps(struct tcpm_port *port, const u32 *pdo,
+			      unsigned int nr_pdo)
+{
+	enum pdo_err err_index = tcpm_caps_err(port, pdo, nr_pdo);
+
+	if (err_index != PDO_NO_ERR) {
+		tcpm_log_force(port, " %s", pdo_err_msg[err_index]);
+		return -EINVAL;
+	}
+
+	return 0;
+}
+
 /*
  * PD (data, control) command handling functions
  */
@@ -1308,6 +1363,9 @@ static void tcpm_pd_data_request(struct tcpm_port *port,
 
 		tcpm_log_source_caps(port);
 
+		tcpm_validate_caps(port, port->source_caps,
+				   port->nr_source_caps);
+
 		/*
 		 * This message may be received even if VBUS is not
 		 * present. This is quite unexpected; see USB PD
@@ -2442,7 +2500,6 @@ static void run_state_machine(struct tcpm_port *port)
 			tcpm_set_state(port, SNK_STARTUP, 0);
 		break;
 	case SNK_STARTUP:
-		/* XXX: callback into infrastructure */
 		opmode =  tcpm_get_pwr_opmode(port->polarity ?
 					      port->cc2 : port->cc1);
 		typec_set_pwr_opmode(port->typec_port, opmode);
@@ -2479,8 +2536,7 @@ static void run_state_machine(struct tcpm_port *port)
 		    tcpm_port_is_sink(port) &&
 		    time_is_after_jiffies(port->delayed_runtime)) {
 			tcpm_set_state(port, SNK_DISCOVERY,
-				       jiffies_to_msecs(port->delayed_runtime -
-							jiffies));
+				       port->delayed_runtime - jiffies);
 			break;
 		}
 		tcpm_set_state(port, unattached_state(port), 0);
@@ -3476,9 +3532,12 @@ static int tcpm_copy_vdos(u32 *dest_vdo, const u32 *src_vdo,
 	return nr_vdo;
 }
 
-void tcpm_update_source_capabilities(struct tcpm_port *port, const u32 *pdo,
-				     unsigned int nr_pdo)
+int tcpm_update_source_capabilities(struct tcpm_port *port, const u32 *pdo,
+				    unsigned int nr_pdo)
 {
+	if (tcpm_validate_caps(port, pdo, nr_pdo))
+		return -EINVAL;
+
 	mutex_lock(&port->lock);
 	port->nr_src_pdo = tcpm_copy_pdos(port->src_pdo, pdo, nr_pdo);
 	switch (port->state) {
@@ -3498,16 +3557,20 @@ void tcpm_update_source_capabilities(struct tcpm_port *port, const u32 *pdo,
 		break;
 	}
 	mutex_unlock(&port->lock);
+	return 0;
 }
 EXPORT_SYMBOL_GPL(tcpm_update_source_capabilities);
 
-void tcpm_update_sink_capabilities(struct tcpm_port *port, const u32 *pdo,
-				   unsigned int nr_pdo,
-				   unsigned int max_snk_mv,
-				   unsigned int max_snk_ma,
-				   unsigned int max_snk_mw,
-				   unsigned int operating_snk_mw)
+int tcpm_update_sink_capabilities(struct tcpm_port *port, const u32 *pdo,
+				  unsigned int nr_pdo,
+				  unsigned int max_snk_mv,
+				  unsigned int max_snk_ma,
+				  unsigned int max_snk_mw,
+				  unsigned int operating_snk_mw)
 {
+	if (tcpm_validate_caps(port, pdo, nr_pdo))
+		return -EINVAL;
+
 	mutex_lock(&port->lock);
 	port->nr_snk_pdo = tcpm_copy_pdos(port->snk_pdo, pdo, nr_pdo);
 	port->max_snk_mv = max_snk_mv;
@@ -3526,6 +3589,7 @@ void tcpm_update_sink_capabilities(struct tcpm_port *port, const u32 *pdo,
 		break;
 	}
 	mutex_unlock(&port->lock);
+	return 0;
 }
 EXPORT_SYMBOL_GPL(tcpm_update_sink_capabilities);
 
@@ -3561,7 +3625,15 @@ struct tcpm_port *tcpm_register_port(struct device *dev, struct tcpc_dev *tcpc)
 
 	init_completion(&port->tx_complete);
 	init_completion(&port->swap_complete);
+	tcpm_debugfs_init(port);
 
+	if (tcpm_validate_caps(port, tcpc->config->src_pdo,
+			       tcpc->config->nr_src_pdo) ||
+	    tcpm_validate_caps(port, tcpc->config->snk_pdo,
+			       tcpc->config->nr_snk_pdo)) {
+		err = -EINVAL;
+		goto out_destroy_wq;
+	}
 	port->nr_src_pdo = tcpm_copy_pdos(port->src_pdo, tcpc->config->src_pdo,
 					  tcpc->config->nr_src_pdo);
 	port->nr_snk_pdo = tcpm_copy_pdos(port->snk_pdo, tcpc->config->snk_pdo,
@@ -3590,11 +3662,6 @@ struct tcpm_port *tcpm_register_port(struct device *dev, struct tcpc_dev *tcpc)
 
 	port->partner_desc.identity = &port->partner_ident;
 	port->port_type = tcpc->config->type;
-	/*
-	 * TODO:
-	 *  - alt_modes, set_alt_mode
-	 *  - {debug,audio}_accessory
-	 */
 
 	port->typec_port = typec_register_port(port->dev, &port->typec_caps);
 	if (!port->typec_port) {
@@ -3621,7 +3688,6 @@ struct tcpm_port *tcpm_register_port(struct device *dev, struct tcpc_dev *tcpc)
 		}
 	}
 
-	tcpm_debugfs_init(port);
 	mutex_lock(&port->lock);
 	tcpm_init(port);
 	mutex_unlock(&port->lock);
@@ -3639,6 +3705,7 @@ void tcpm_unregister_port(struct tcpm_port *port)
 {
 	int i;
 
+	tcpm_reset_port(port);
 	for (i = 0; i < ARRAY_SIZE(port->port_altmode); i++)
 		typec_unregister_altmode(port->port_altmode[i]);
 	typec_unregister_port(port->typec_port);
diff --git a/drivers/usb/typec/tps6598x.c b/drivers/usb/typec/tps6598x.c
new file mode 100644
index 000000000000..7b01648c85ca
--- /dev/null
+++ b/drivers/usb/typec/tps6598x.c
@@ -0,0 +1,504 @@
+// SPDX-License-Identifier: GPL-2.0
+/*
+ * Driver for TI TPS6598x USB Power Delivery controller family
+ *
+ * Copyright (C) 2017, Intel Corporation
+ * Author: Heikki Krogerus <heikki.krogerus@linux.intel.com>
+ */
+
+#include <linux/i2c.h>
+#include <linux/acpi.h>
+#include <linux/module.h>
+#include <linux/regmap.h>
+#include <linux/interrupt.h>
+#include <linux/usb/typec.h>
+
+/* Register offsets */
+#define TPS_REG_CMD1			0x08
+#define TPS_REG_DATA1			0x09
+#define TPS_REG_INT_EVENT1		0x14
+#define TPS_REG_INT_EVENT2		0x15
+#define TPS_REG_INT_MASK1		0x16
+#define TPS_REG_INT_MASK2		0x17
+#define TPS_REG_INT_CLEAR1		0x18
+#define TPS_REG_INT_CLEAR2		0x19
+#define TPS_REG_STATUS			0x1a
+#define TPS_REG_SYSTEM_CONF		0x28
+#define TPS_REG_CTRL_CONF		0x29
+#define TPS_REG_POWER_STATUS		0x3f
+#define TPS_REG_RX_IDENTITY_SOP		0x48
+
+/* TPS_REG_INT_* bits */
+#define TPS_REG_INT_PLUG_EVENT		BIT(3)
+
+/* TPS_REG_STATUS bits */
+#define TPS_STATUS_PLUG_PRESENT		BIT(0)
+#define TPS_STATUS_ORIENTATION		BIT(4)
+#define TPS_STATUS_PORTROLE(s)		(!!((s) & BIT(5)))
+#define TPS_STATUS_DATAROLE(s)		(!!((s) & BIT(6)))
+#define TPS_STATUS_VCONN(s)		(!!((s) & BIT(7)))
+
+/* TPS_REG_SYSTEM_CONF bits */
+#define TPS_SYSCONF_PORTINFO(c)		((c) & 3)
+
+enum {
+	TPS_PORTINFO_SINK,
+	TPS_PORTINFO_SINK_ACCESSORY,
+	TPS_PORTINFO_DRP_UFP,
+	TPS_PORTINFO_DRP_UFP_DRD,
+	TPS_PORTINFO_DRP_DFP,
+	TPS_PORTINFO_DRP_DFP_DRD,
+	TPS_PORTINFO_SOURCE,
+};
+
+/* TPS_REG_POWER_STATUS bits */
+#define TPS_POWER_STATUS_SOURCESINK	BIT(1)
+#define TPS_POWER_STATUS_PWROPMODE(p)	(((p) & GENMASK(3, 2)) >> 2)
+
+/* TPS_REG_RX_IDENTITY_SOP */
+struct tps6598x_rx_identity_reg {
+	u8 status;
+	struct usb_pd_identity identity;
+	u32 vdo[3];
+} __packed;
+
+/* Standard Task return codes */
+#define TPS_TASK_TIMEOUT		1
+#define TPS_TASK_REJECTED		3
+
+/* Unrecognized commands will be replaced with "!CMD" */
+#define INVALID_CMD(_cmd_)		(_cmd_ == 0x444d4321)
+
+struct tps6598x {
+	struct device *dev;
+	struct regmap *regmap;
+	struct mutex lock; /* device lock */
+	u8 i2c_protocol:1;
+
+	struct typec_port *port;
+	struct typec_partner *partner;
+	struct usb_pd_identity partner_identity;
+	struct typec_capability typec_cap;
+};
+
+static int
+tps6598x_block_read(struct tps6598x *tps, u8 reg, void *val, size_t len)
+{
+	u8 data[len + 1];
+	int ret;
+
+	if (!tps->i2c_protocol)
+		return regmap_raw_read(tps->regmap, reg, val, len);
+
+	ret = regmap_raw_read(tps->regmap, reg, data, sizeof(data));
+	if (ret)
+		return ret;
+
+	if (data[0] < len)
+		return -EIO;
+
+	memcpy(val, &data[1], len);
+	return 0;
+}
+
+static inline int tps6598x_read16(struct tps6598x *tps, u8 reg, u16 *val)
+{
+	return tps6598x_block_read(tps, reg, val, sizeof(u16));
+}
+
+static inline int tps6598x_read32(struct tps6598x *tps, u8 reg, u32 *val)
+{
+	return tps6598x_block_read(tps, reg, val, sizeof(u32));
+}
+
+static inline int tps6598x_read64(struct tps6598x *tps, u8 reg, u64 *val)
+{
+	return tps6598x_block_read(tps, reg, val, sizeof(u64));
+}
+
+static inline int tps6598x_write16(struct tps6598x *tps, u8 reg, u16 val)
+{
+	return regmap_raw_write(tps->regmap, reg, &val, sizeof(u16));
+}
+
+static inline int tps6598x_write32(struct tps6598x *tps, u8 reg, u32 val)
+{
+	return regmap_raw_write(tps->regmap, reg, &val, sizeof(u32));
+}
+
+static inline int tps6598x_write64(struct tps6598x *tps, u8 reg, u64 val)
+{
+	return regmap_raw_write(tps->regmap, reg, &val, sizeof(u64));
+}
+
+static inline int
+tps6598x_write_4cc(struct tps6598x *tps, u8 reg, const char *val)
+{
+	return regmap_raw_write(tps->regmap, reg, &val, sizeof(u32));
+}
+
+static int tps6598x_read_partner_identity(struct tps6598x *tps)
+{
+	struct tps6598x_rx_identity_reg id;
+	int ret;
+
+	ret = tps6598x_block_read(tps, TPS_REG_RX_IDENTITY_SOP,
+				  &id, sizeof(id));
+	if (ret)
+		return ret;
+
+	tps->partner_identity = id.identity;
+
+	return 0;
+}
+
+static int tps6598x_connect(struct tps6598x *tps, u32 status)
+{
+	struct typec_partner_desc desc;
+	enum typec_pwr_opmode mode;
+	u16 pwr_status;
+	int ret;
+
+	if (tps->partner)
+		return 0;
+
+	ret = tps6598x_read16(tps, TPS_REG_POWER_STATUS, &pwr_status);
+	if (ret < 0)
+		return ret;
+
+	mode = TPS_POWER_STATUS_PWROPMODE(pwr_status);
+
+	desc.usb_pd = mode == TYPEC_PWR_MODE_PD;
+	desc.accessory = TYPEC_ACCESSORY_NONE; /* XXX: handle accessories */
+	desc.identity = NULL;
+
+	if (desc.usb_pd) {
+		ret = tps6598x_read_partner_identity(tps);
+		if (ret)
+			return ret;
+		desc.identity = &tps->partner_identity;
+	}
+
+	tps->partner = typec_register_partner(tps->port, &desc);
+	if (!tps->partner)
+		return -ENODEV;
+
+	typec_set_pwr_opmode(tps->port, mode);
+	typec_set_pwr_role(tps->port, TPS_STATUS_PORTROLE(status));
+	typec_set_vconn_role(tps->port, TPS_STATUS_VCONN(status));
+	typec_set_data_role(tps->port, TPS_STATUS_DATAROLE(status));
+
+	if (desc.identity)
+		typec_partner_set_identity(tps->partner);
+
+	return 0;
+}
+
+static void tps6598x_disconnect(struct tps6598x *tps, u32 status)
+{
+	typec_unregister_partner(tps->partner);
+	tps->partner = NULL;
+	typec_set_pwr_opmode(tps->port, TYPEC_PWR_MODE_USB);
+	typec_set_pwr_role(tps->port, TPS_STATUS_PORTROLE(status));
+	typec_set_vconn_role(tps->port, TPS_STATUS_VCONN(status));
+	typec_set_data_role(tps->port, TPS_STATUS_DATAROLE(status));
+}
+
+static int tps6598x_exec_cmd(struct tps6598x *tps, const char *cmd,
+			     size_t in_len, u8 *in_data,
+			     size_t out_len, u8 *out_data)
+{
+	unsigned long timeout;
+	u32 val;
+	int ret;
+
+	ret = tps6598x_read32(tps, TPS_REG_CMD1, &val);
+	if (ret)
+		return ret;
+	if (val && !INVALID_CMD(val))
+		return -EBUSY;
+
+	if (in_len) {
+		ret = regmap_raw_write(tps->regmap, TPS_REG_DATA1,
+				       in_data, in_len);
+		if (ret)
+			return ret;
+	}
+
+	ret = tps6598x_write_4cc(tps, TPS_REG_CMD1, cmd);
+	if (ret < 0)
+		return ret;
+
+	/* XXX: Using 1s for now, but it may not be enough for every command. */
+	timeout = jiffies + msecs_to_jiffies(1000);
+
+	do {
+		ret = tps6598x_read32(tps, TPS_REG_CMD1, &val);
+		if (ret)
+			return ret;
+		if (INVALID_CMD(val))
+			return -EINVAL;
+
+		if (time_is_before_jiffies(timeout))
+			return -ETIMEDOUT;
+	} while (val);
+
+	if (out_len) {
+		ret = tps6598x_block_read(tps, TPS_REG_DATA1,
+					  out_data, out_len);
+		if (ret)
+			return ret;
+		val = out_data[0];
+	} else {
+		ret = tps6598x_block_read(tps, TPS_REG_DATA1, &val, sizeof(u8));
+		if (ret)
+			return ret;
+	}
+
+	switch (val) {
+	case TPS_TASK_TIMEOUT:
+		return -ETIMEDOUT;
+	case TPS_TASK_REJECTED:
+		return -EPERM;
+	default:
+		break;
+	}
+
+	return 0;
+}
+
+static int
+tps6598x_dr_set(const struct typec_capability *cap, enum typec_data_role role)
+{
+	struct tps6598x *tps = container_of(cap, struct tps6598x, typec_cap);
+	const char *cmd = (role == TYPEC_DEVICE) ? "SWUF" : "SWDF";
+	u32 status;
+	int ret;
+
+	mutex_lock(&tps->lock);
+
+	ret = tps6598x_exec_cmd(tps, cmd, 0, NULL, 0, NULL);
+	if (ret)
+		goto out_unlock;
+
+	ret = tps6598x_read32(tps, TPS_REG_STATUS, &status);
+	if (ret)
+		goto out_unlock;
+
+	if (role != TPS_STATUS_DATAROLE(status)) {
+		ret = -EPROTO;
+		goto out_unlock;
+	}
+
+	typec_set_data_role(tps->port, role);
+
+out_unlock:
+	mutex_unlock(&tps->lock);
+
+	return ret;
+}
+
+static int
+tps6598x_pr_set(const struct typec_capability *cap, enum typec_role role)
+{
+	struct tps6598x *tps = container_of(cap, struct tps6598x, typec_cap);
+	const char *cmd = (role == TYPEC_SINK) ? "SWSk" : "SWSr";
+	u32 status;
+	int ret;
+
+	mutex_lock(&tps->lock);
+
+	ret = tps6598x_exec_cmd(tps, cmd, 0, NULL, 0, NULL);
+	if (ret)
+		goto out_unlock;
+
+	ret = tps6598x_read32(tps, TPS_REG_STATUS, &status);
+	if (ret)
+		goto out_unlock;
+
+	if (role != TPS_STATUS_PORTROLE(status)) {
+		ret = -EPROTO;
+		goto out_unlock;
+	}
+
+	typec_set_pwr_role(tps->port, role);
+
+out_unlock:
+	mutex_unlock(&tps->lock);
+
+	return ret;
+}
+
+static irqreturn_t tps6598x_interrupt(int irq, void *data)
+{
+	struct tps6598x *tps = data;
+	u64 event1;
+	u64 event2;
+	u32 status;
+	int ret;
+
+	mutex_lock(&tps->lock);
+
+	ret = tps6598x_read64(tps, TPS_REG_INT_EVENT1, &event1);
+	ret |= tps6598x_read64(tps, TPS_REG_INT_EVENT2, &event2);
+	if (ret) {
+		dev_err(tps->dev, "%s: failed to read events\n", __func__);
+		goto err_unlock;
+	}
+
+	ret = tps6598x_read32(tps, TPS_REG_STATUS, &status);
+	if (ret) {
+		dev_err(tps->dev, "%s: failed to read status\n", __func__);
+		goto err_clear_ints;
+	}
+
+	/* Handle plug insert or removal */
+	if ((event1 | event2) & TPS_REG_INT_PLUG_EVENT) {
+		if (status & TPS_STATUS_PLUG_PRESENT) {
+			ret = tps6598x_connect(tps, status);
+			if (ret)
+				dev_err(tps->dev,
+					"failed to register partner\n");
+		} else {
+			tps6598x_disconnect(tps, status);
+		}
+	}
+
+err_clear_ints:
+	tps6598x_write64(tps, TPS_REG_INT_CLEAR1, event1);
+	tps6598x_write64(tps, TPS_REG_INT_CLEAR2, event2);
+
+err_unlock:
+	mutex_unlock(&tps->lock);
+
+	return IRQ_HANDLED;
+}
+
+static const struct regmap_config tps6598x_regmap_config = {
+	.reg_bits = 8,
+	.val_bits = 8,
+	.max_register = 0x7F,
+};
+
+static int tps6598x_probe(struct i2c_client *client)
+{
+	struct tps6598x *tps;
+	u32 status;
+	u32 conf;
+	u32 vid;
+	int ret;
+
+	tps = devm_kzalloc(&client->dev, sizeof(*tps), GFP_KERNEL);
+	if (!tps)
+		return -ENOMEM;
+
+	mutex_init(&tps->lock);
+	tps->dev = &client->dev;
+
+	tps->regmap = devm_regmap_init_i2c(client, &tps6598x_regmap_config);
+	if (IS_ERR(tps->regmap))
+		return PTR_ERR(tps->regmap);
+
+	ret = tps6598x_read32(tps, 0, &vid);
+	if (ret < 0)
+		return ret;
+	if (!vid)
+		return -ENODEV;
+
+	/*
+	 * Checking can the adapter handle SMBus protocol. If it can not, the
+	 * driver needs to take care of block reads separately.
+	 *
+	 * FIXME: Testing with I2C_FUNC_I2C. regmap-i2c uses I2C protocol
+	 * unconditionally if the adapter has I2C_FUNC_I2C set.
+	 */
+	if (i2c_check_functionality(client->adapter, I2C_FUNC_I2C))
+		tps->i2c_protocol = true;
+
+	ret = tps6598x_read32(tps, TPS_REG_STATUS, &status);
+	if (ret < 0)
+		return ret;
+
+	ret = tps6598x_read32(tps, TPS_REG_SYSTEM_CONF, &conf);
+	if (ret < 0)
+		return ret;
+
+	switch (TPS_SYSCONF_PORTINFO(conf)) {
+	case TPS_PORTINFO_SINK_ACCESSORY:
+	case TPS_PORTINFO_SINK:
+		tps->typec_cap.type = TYPEC_PORT_UFP;
+		break;
+	case TPS_PORTINFO_DRP_UFP_DRD:
+	case TPS_PORTINFO_DRP_DFP_DRD:
+		tps->typec_cap.dr_set = tps6598x_dr_set;
+		/* fall through */
+	case TPS_PORTINFO_DRP_UFP:
+	case TPS_PORTINFO_DRP_DFP:
+		tps->typec_cap.pr_set = tps6598x_pr_set;
+		tps->typec_cap.type = TYPEC_PORT_DRP;
+		break;
+	case TPS_PORTINFO_SOURCE:
+		tps->typec_cap.type = TYPEC_PORT_DFP;
+		break;
+	default:
+		return -ENODEV;
+	}
+
+	tps->typec_cap.revision = USB_TYPEC_REV_1_2;
+	tps->typec_cap.pd_revision = 0x200;
+	tps->typec_cap.prefer_role = TYPEC_NO_PREFERRED_ROLE;
+
+	tps->port = typec_register_port(&client->dev, &tps->typec_cap);
+	if (!tps->port)
+		return -ENODEV;
+
+	if (status & TPS_STATUS_PLUG_PRESENT) {
+		ret = tps6598x_connect(tps, status);
+		if (ret)
+			dev_err(&client->dev, "failed to register partner\n");
+	}
+
+	ret = devm_request_threaded_irq(&client->dev, client->irq, NULL,
+					tps6598x_interrupt,
+					IRQF_SHARED | IRQF_ONESHOT,
+					dev_name(&client->dev), tps);
+	if (ret) {
+		tps6598x_disconnect(tps, 0);
+		typec_unregister_port(tps->port);
+		return ret;
+	}
+
+	i2c_set_clientdata(client, tps);
+
+	return 0;
+}
+
+static int tps6598x_remove(struct i2c_client *client)
+{
+	struct tps6598x *tps = i2c_get_clientdata(client);
+
+	tps6598x_disconnect(tps, 0);
+	typec_unregister_port(tps->port);
+
+	return 0;
+}
+
+static const struct acpi_device_id tps6598x_acpi_match[] = {
+	{ "INT3515", 0 },
+	{ }
+};
+MODULE_DEVICE_TABLE(acpi, tps6598x_acpi_match);
+
+static struct i2c_driver tps6598x_i2c_driver = {
+	.driver = {
+		.name = "tps6598x",
+		.acpi_match_table = tps6598x_acpi_match,
+	},
+	.probe_new = tps6598x_probe,
+	.remove = tps6598x_remove,
+};
+module_i2c_driver(tps6598x_i2c_driver);
+
+MODULE_AUTHOR("Heikki Krogerus <heikki.krogerus@linux.intel.com>");
+MODULE_LICENSE("GPL v2");
+MODULE_DESCRIPTION("TI TPS6598x USB Power Delivery Controller Driver");
diff --git a/drivers/usb/typec/typec.c b/drivers/usb/typec/typec.c
index 24e355ba109d..735726ced602 100644
--- a/drivers/usb/typec/typec.c
+++ b/drivers/usb/typec/typec.c
@@ -1,12 +1,9 @@
+// SPDX-License-Identifier: GPL-2.0
 /*
  * USB Type-C Connector Class
  *
  * Copyright (C) 2017, Intel Corporation
  * Author: Heikki Krogerus <heikki.krogerus@linux.intel.com>
- *
- * This program is free software; you can redistribute it and/or modify
- * it under the terms of the GNU General Public License version 2 as
- * published by the Free Software Foundation.
  */
 
 #include <linux/device.h>
diff --git a/drivers/usb/typec/typec_wcove.c b/drivers/usb/typec/typec_wcove.c
index e9c4e784a9cb..1e13d4e15831 100644
--- a/drivers/usb/typec/typec_wcove.c
+++ b/drivers/usb/typec/typec_wcove.c
@@ -1,24 +1,20 @@
+// SPDX-License-Identifier: GPL-2.0
 /**
  * typec_wcove.c - WhiskeyCove PMIC USB Type-C PHY driver
  *
  * Copyright (C) 2017 Intel Corporation
  * Author: Heikki Krogerus <heikki.krogerus@linux.intel.com>
- *
- * This program is free software; you can redistribute it and/or modify
- * it under the terms of the GNU General Public License version 2 as
- * published by the Free Software Foundation.
  */
 
 #include <linux/acpi.h>
 #include <linux/module.h>
+#include <linux/usb/tcpm.h>
 #include <linux/interrupt.h>
-#include <linux/usb/typec.h>
 #include <linux/platform_device.h>
 #include <linux/mfd/intel_soc_pmic.h>
 
 /* Register offsets */
 #define WCOVE_CHGRIRQ0		0x4e09
-#define WCOVE_PHYCTRL		0x5e07
 
 #define USBC_CONTROL1		0x7001
 #define USBC_CONTROL2		0x7002
@@ -28,22 +24,57 @@
 #define USBC_STATUS1		0x7007
 #define USBC_STATUS2		0x7008
 #define USBC_STATUS3		0x7009
+#define USBC_CC1		0x700a
+#define USBC_CC2		0x700b
+#define USBC_CC1_STATUS		0x700c
+#define USBC_CC2_STATUS		0x700d
 #define USBC_IRQ1		0x7015
 #define USBC_IRQ2		0x7016
 #define USBC_IRQMASK1		0x7017
 #define USBC_IRQMASK2		0x7018
+#define USBC_PDCFG2		0x701a
+#define USBC_PDCFG3		0x701b
+#define USBC_PDSTATUS		0x701c
+#define USBC_RXSTATUS		0x701d
+#define USBC_RXINFO		0x701e
+#define USBC_TXCMD		0x701f
+#define USBC_TXINFO		0x7020
+#define USBC_RX_DATA		0x7028
+#define USBC_TX_DATA		0x7047
 
 /* Register bits */
 
-#define USBC_CONTROL1_MODE_DRP(r)	(((r) & ~0x7) | 4)
+#define USBC_CONTROL1_MODE_MASK		0x3
+#define   USBC_CONTROL1_MODE_SNK	0
+#define   USBC_CONTROL1_MODE_SNKACC	1
+#define   USBC_CONTROL1_MODE_SRC	2
+#define   USBC_CONTROL1_MODE_SRCACC	3
+#define   USBC_CONTROL1_MODE_DRP	4
+#define   USBC_CONTROL1_MODE_DRPACC	5
+#define   USBC_CONTROL1_MODE_TEST	7
+#define USBC_CONTROL1_CURSRC_MASK	0xc
+#define   USBC_CONTROL1_CURSRC_UA_0	(0 << 3)
+#define   USBC_CONTROL1_CURSRC_UA_80	(1 << 3)
+#define   USBC_CONTROL1_CURSRC_UA_180	(2 << 3)
+#define   USBC_CONTROL1_CURSRC_UA_330	(3 << 3)
+#define USBC_CONTROL1_DRPTOGGLE_RANDOM	0xe0
 
 #define USBC_CONTROL2_UNATT_SNK		BIT(0)
 #define USBC_CONTROL2_UNATT_SRC		BIT(1)
 #define USBC_CONTROL2_DIS_ST		BIT(2)
 
+#define USBC_CONTROL3_DET_DIS		BIT(0)
 #define USBC_CONTROL3_PD_DIS		BIT(1)
+#define USBC_CONTROL3_RESETPHY		BIT(2)
 
+#define USBC_CC_CTRL_PU_EN		BIT(0)
 #define USBC_CC_CTRL_VCONN_EN		BIT(1)
+#define USBC_CC_CTRL_TX_EN		BIT(2)
+#define USBC_CC_CTRL_PD_EN		BIT(3)
+#define USBC_CC_CTRL_CDET_EN		BIT(4)
+#define USBC_CC_CTRL_RDET_EN		BIT(5)
+#define USBC_CC_CTRL_ADC_EN		BIT(6)
+#define USBC_CC_CTRL_VBUSOK		BIT(7)
 
 #define USBC_STATUS1_DET_ONGOING	BIT(6)
 #define USBC_STATUS1_RSLT(r)		((r) & 0xf)
@@ -61,6 +92,15 @@
 
 #define USBC_STATUS2_VBUS_REQ		BIT(5)
 
+#define UCSC_CC_STATUS_SNK_RP		BIT(0)
+#define UCSC_CC_STATUS_PWRDEFSNK	BIT(1)
+#define UCSC_CC_STATUS_PWR_1P5A_SNK	BIT(2)
+#define UCSC_CC_STATUS_PWR_3A_SNK	BIT(3)
+#define UCSC_CC_STATUS_SRC_RP		BIT(4)
+#define UCSC_CC_STATUS_RX(r)		(((r) >> 5) & 0x3)
+#define   USBC_CC_STATUS_RD		1
+#define   USBC_CC_STATUS_RA		2
+
 #define USBC_IRQ1_ADCDONE1		BIT(2)
 #define USBC_IRQ1_OVERTEMP		BIT(1)
 #define USBC_IRQ1_SHORT			BIT(0)
@@ -79,15 +119,44 @@
 				 USBC_IRQ2_RX_HR | USBC_IRQ2_RX_CR | \
 				 USBC_IRQ2_TX_SUCCESS | USBC_IRQ2_TX_FAIL)
 
+#define USBC_PDCFG2_SOP			BIT(0)
+#define USBC_PDCFG2_SOP_P		BIT(1)
+#define USBC_PDCFG2_SOP_PP		BIT(2)
+#define USBC_PDCFG2_SOP_P_DEBUG		BIT(3)
+#define USBC_PDCFG2_SOP_PP_DEBUG	BIT(4)
+
+#define USBC_PDCFG3_DATAROLE_SHIFT	1
+#define USBC_PDCFG3_SOP_SHIFT		2
+
+#define USBC_RXSTATUS_RXCLEAR		BIT(0)
+#define USBC_RXSTATUS_RXDATA		BIT(7)
+
+#define USBC_RXINFO_RXBYTES(i)		(((i) >> 3) & 0x1f)
+
+#define USBC_TXCMD_BUF_RDY		BIT(0)
+#define USBC_TXCMD_START		BIT(1)
+#define USBC_TXCMD_NOP			(0 << 5)
+#define USBC_TXCMD_MSG			(1 << 5)
+#define USBC_TXCMD_CR			(2 << 5)
+#define USBC_TXCMD_HR			(3 << 5)
+#define USBC_TXCMD_BIST			(4 << 5)
+
+#define USBC_TXINFO_RETRIES(d)		(d << 3)
+
 struct wcove_typec {
 	struct mutex lock; /* device lock */
 	struct device *dev;
 	struct regmap *regmap;
-	struct typec_port *port;
-	struct typec_capability cap;
-	struct typec_partner *partner;
+	guid_t guid;
+
+	bool vbus;
+
+	struct tcpc_dev tcpc;
+	struct tcpm_port *tcpm;
 };
 
+#define tcpc_to_wcove(_tcpc_) container_of(_tcpc_, struct wcove_typec, tcpc)
+
 enum wcove_typec_func {
 	WCOVE_FUNC_DRIVE_VBUS = 1,
 	WCOVE_FUNC_ORIENTATION,
@@ -105,8 +174,7 @@ enum wcove_typec_role {
 	WCOVE_ROLE_DEVICE,
 };
 
-static guid_t guid = GUID_INIT(0x482383f0, 0x2876, 0x4e49,
-			       0x86, 0x85, 0xdb, 0x66, 0x21, 0x1a, 0xf0, 0x37);
+#define WCOVE_DSM_UUID		"482383f0-2876-4e49-8685-db66211af037"
 
 static int wcove_typec_func(struct wcove_typec *wcove,
 			    enum wcove_typec_func func, int param)
@@ -118,7 +186,7 @@ static int wcove_typec_func(struct wcove_typec *wcove,
 	tmp.type = ACPI_TYPE_INTEGER;
 	tmp.integer.value = param;
 
-	obj = acpi_evaluate_dsm(ACPI_HANDLE(wcove->dev), &guid, 1, func,
+	obj = acpi_evaluate_dsm(ACPI_HANDLE(wcove->dev), &wcove->guid, 1, func,
 				&argv4);
 	if (!obj) {
 		dev_err(wcove->dev, "%s: failed to evaluate _DSM\n", __func__);
@@ -129,158 +197,375 @@ static int wcove_typec_func(struct wcove_typec *wcove,
 	return 0;
 }
 
-static irqreturn_t wcove_typec_irq(int irq, void *data)
+static int wcove_init(struct tcpc_dev *tcpc)
 {
-	enum typec_role role = TYPEC_SINK;
-	struct typec_partner_desc partner;
-	struct wcove_typec *wcove = data;
-	unsigned int cc1_ctrl;
-	unsigned int cc2_ctrl;
-	unsigned int cc_irq1;
-	unsigned int cc_irq2;
-	unsigned int status1;
-	unsigned int status2;
+	struct wcove_typec *wcove = tcpc_to_wcove(tcpc);
 	int ret;
 
-	mutex_lock(&wcove->lock);
-
-	ret = regmap_read(wcove->regmap, USBC_IRQ1, &cc_irq1);
+	ret = regmap_write(wcove->regmap, USBC_CONTROL1, 0);
 	if (ret)
-		goto err;
+		return ret;
 
-	ret = regmap_read(wcove->regmap, USBC_IRQ2, &cc_irq2);
+	/* Unmask everything */
+	ret = regmap_write(wcove->regmap, USBC_IRQMASK1, 0);
 	if (ret)
-		goto err;
+		return ret;
 
-	ret = regmap_read(wcove->regmap, USBC_STATUS1, &status1);
-	if (ret)
-		goto err;
+	return regmap_write(wcove->regmap, USBC_IRQMASK2, 0);
+}
 
-	ret = regmap_read(wcove->regmap, USBC_STATUS2, &status2);
-	if (ret)
-		goto err;
+static int wcove_get_vbus(struct tcpc_dev *tcpc)
+{
+	struct wcove_typec *wcove = tcpc_to_wcove(tcpc);
+	unsigned int cc1ctrl;
+	int ret;
 
-	ret = regmap_read(wcove->regmap, USBC_CC1_CTRL, &cc1_ctrl);
+	ret = regmap_read(wcove->regmap, USBC_CC1_CTRL, &cc1ctrl);
 	if (ret)
-		goto err;
+		return ret;
 
-	ret = regmap_read(wcove->regmap, USBC_CC2_CTRL, &cc2_ctrl);
-	if (ret)
-		goto err;
+	wcove->vbus = !!(cc1ctrl & USBC_CC_CTRL_VBUSOK);
 
-	if (cc_irq1) {
-		if (cc_irq1 & USBC_IRQ1_OVERTEMP)
-			dev_err(wcove->dev, "VCONN Switch Over Temperature!\n");
-		if (cc_irq1 & USBC_IRQ1_SHORT)
-			dev_err(wcove->dev, "VCONN Switch Short Circuit!\n");
-		ret = regmap_write(wcove->regmap, USBC_IRQ1, cc_irq1);
-		if (ret)
-			goto err;
-	}
+	return wcove->vbus;
+}
 
-	if (cc_irq2) {
-		ret = regmap_write(wcove->regmap, USBC_IRQ2, cc_irq2);
-		if (ret)
-			goto err;
-		/*
-		 * Ignoring any PD communication interrupts until the PD support
-		 * is available
-		 */
-		if (cc_irq2 & ~USBC_IRQ2_CC_CHANGE) {
-			dev_WARN(wcove->dev, "USB PD handling missing\n");
-			goto err;
-		}
-	}
+static int wcove_set_vbus(struct tcpc_dev *tcpc, bool on, bool sink)
+{
+	struct wcove_typec *wcove = tcpc_to_wcove(tcpc);
+
+	return wcove_typec_func(wcove, WCOVE_FUNC_DRIVE_VBUS, on);
+}
+
+static int wcove_set_vconn(struct tcpc_dev *tcpc, bool on)
+{
+	struct wcove_typec *wcove = tcpc_to_wcove(tcpc);
 
-	if (status1 & USBC_STATUS1_DET_ONGOING)
-		goto out;
+	return wcove_typec_func(wcove, WCOVE_FUNC_DRIVE_VCONN, on);
+}
 
-	if (USBC_STATUS1_RSLT(status1) == USBC_RSLT_NOTHING) {
-		if (wcove->partner) {
-			typec_unregister_partner(wcove->partner);
-			wcove->partner = NULL;
+static enum typec_cc_status wcove_to_typec_cc(unsigned int cc)
+{
+	if (cc & UCSC_CC_STATUS_SNK_RP) {
+		if (cc & UCSC_CC_STATUS_PWRDEFSNK)
+			return TYPEC_CC_RP_DEF;
+		else if (cc & UCSC_CC_STATUS_PWR_1P5A_SNK)
+			return TYPEC_CC_RP_1_5;
+		else if (cc & UCSC_CC_STATUS_PWR_3A_SNK)
+			return TYPEC_CC_RP_3_0;
+	} else {
+		switch (UCSC_CC_STATUS_RX(cc)) {
+		case USBC_CC_STATUS_RD:
+			return TYPEC_CC_RD;
+		case USBC_CC_STATUS_RA:
+			return TYPEC_CC_RA;
+		default:
+			break;
 		}
+	}
+	return TYPEC_CC_OPEN;
+}
 
-		wcove_typec_func(wcove, WCOVE_FUNC_ORIENTATION,
-				 WCOVE_ORIENTATION_NORMAL);
+static int wcove_get_cc(struct tcpc_dev *tcpc, enum typec_cc_status *cc1,
+			enum typec_cc_status *cc2)
+{
+	struct wcove_typec *wcove = tcpc_to_wcove(tcpc);
+	unsigned int cc1_status;
+	unsigned int cc2_status;
+	int ret;
 
-		/* This makes sure the device controller is disconnected */
-		wcove_typec_func(wcove, WCOVE_FUNC_ROLE, WCOVE_ROLE_HOST);
+	ret = regmap_read(wcove->regmap, USBC_CC1_STATUS, &cc1_status);
+	if (ret)
+		return ret;
 
-		/* Port to default role */
-		typec_set_data_role(wcove->port, TYPEC_DEVICE);
-		typec_set_pwr_role(wcove->port, TYPEC_SINK);
-		typec_set_pwr_opmode(wcove->port, TYPEC_PWR_MODE_USB);
+	ret = regmap_read(wcove->regmap, USBC_CC2_STATUS, &cc2_status);
+	if (ret)
+		return ret;
 
-		goto out;
-	}
+	*cc1 = wcove_to_typec_cc(cc1_status);
+	*cc2 = wcove_to_typec_cc(cc2_status);
+
+	return 0;
+}
 
-	if (wcove->partner)
-		goto out;
+static int wcove_set_cc(struct tcpc_dev *tcpc, enum typec_cc_status cc)
+{
+	struct wcove_typec *wcove = tcpc_to_wcove(tcpc);
+	unsigned int ctrl;
 
-	switch (USBC_STATUS1_ORIENT(status1)) {
-	case USBC_ORIENT_NORMAL:
-		wcove_typec_func(wcove, WCOVE_FUNC_ORIENTATION,
-				 WCOVE_ORIENTATION_NORMAL);
+	switch (cc) {
+	case TYPEC_CC_RD:
+		ctrl = USBC_CONTROL1_MODE_SNK;
 		break;
-	case USBC_ORIENT_REVERSE:
-		wcove_typec_func(wcove, WCOVE_FUNC_ORIENTATION,
-				 WCOVE_ORIENTATION_REVERSE);
-	default:
+	case TYPEC_CC_RP_DEF:
+		ctrl = USBC_CONTROL1_CURSRC_UA_80 | USBC_CONTROL1_MODE_SRC;
+		break;
+	case TYPEC_CC_RP_1_5:
+		ctrl = USBC_CONTROL1_CURSRC_UA_180 | USBC_CONTROL1_MODE_SRC;
+		break;
+	case TYPEC_CC_RP_3_0:
+		ctrl = USBC_CONTROL1_CURSRC_UA_330 | USBC_CONTROL1_MODE_SRC;
 		break;
+	case TYPEC_CC_OPEN:
+		ctrl = 0;
+		break;
+	default:
+		return -EINVAL;
+	}
+
+	return regmap_write(wcove->regmap, USBC_CONTROL1, ctrl);
+}
+
+static int wcove_set_polarity(struct tcpc_dev *tcpc, enum typec_cc_polarity pol)
+{
+	struct wcove_typec *wcove = tcpc_to_wcove(tcpc);
+
+	return wcove_typec_func(wcove, WCOVE_FUNC_ORIENTATION, pol);
+}
+
+static int wcove_set_current_limit(struct tcpc_dev *tcpc, u32 max_ma, u32 mv)
+{
+	return 0;
+}
+
+static int wcove_set_roles(struct tcpc_dev *tcpc, bool attached,
+			   enum typec_role role, enum typec_data_role data)
+{
+	struct wcove_typec *wcove = tcpc_to_wcove(tcpc);
+	unsigned int val;
+	int ret;
+
+	ret = wcove_typec_func(wcove, WCOVE_FUNC_ROLE, data == TYPEC_HOST ?
+			       WCOVE_ROLE_HOST : WCOVE_ROLE_DEVICE);
+	if (ret)
+		return ret;
+
+	val = role;
+	val |= data << USBC_PDCFG3_DATAROLE_SHIFT;
+	val |= PD_REV20 << USBC_PDCFG3_SOP_SHIFT;
+
+	return regmap_write(wcove->regmap, USBC_PDCFG3, val);
+}
+
+static int wcove_set_pd_rx(struct tcpc_dev *tcpc, bool on)
+{
+	struct wcove_typec *wcove = tcpc_to_wcove(tcpc);
+
+	return regmap_write(wcove->regmap, USBC_PDCFG2,
+			    on ? USBC_PDCFG2_SOP : 0);
+}
+
+static int wcove_pd_transmit(struct tcpc_dev *tcpc,
+			     enum tcpm_transmit_type type,
+			     const struct pd_message *msg)
+{
+	struct wcove_typec *wcove = tcpc_to_wcove(tcpc);
+	unsigned int info = 0;
+	unsigned int cmd;
+	int ret;
+
+	ret = regmap_read(wcove->regmap, USBC_TXCMD, &cmd);
+	if (ret)
+		return ret;
+
+	if (!(cmd & USBC_TXCMD_BUF_RDY)) {
+		dev_warn(wcove->dev, "%s: Last transmission still ongoing!",
+			 __func__);
+		return -EBUSY;
 	}
 
-	memset(&partner, 0, sizeof(partner));
+	if (msg) {
+		const u8 *data = (void *)msg;
+		int i;
+
+		for (i = 0; i < pd_header_cnt(msg->header) * 4 + 2; i++) {
+			ret = regmap_write(wcove->regmap, USBC_TX_DATA + i,
+					   data[i]);
+			if (ret)
+				return ret;
+		}
+	}
 
-	switch (USBC_STATUS1_RSLT(status1)) {
-	case USBC_RSLT_SRC_DEFAULT:
-		typec_set_pwr_opmode(wcove->port, TYPEC_PWR_MODE_USB);
+	switch (type) {
+	case TCPC_TX_SOP:
+	case TCPC_TX_SOP_PRIME:
+	case TCPC_TX_SOP_PRIME_PRIME:
+	case TCPC_TX_SOP_DEBUG_PRIME:
+	case TCPC_TX_SOP_DEBUG_PRIME_PRIME:
+		info = type + 1;
+		cmd = USBC_TXCMD_MSG;
 		break;
-	case USBC_RSLT_SRC_1_5A:
-		typec_set_pwr_opmode(wcove->port, TYPEC_PWR_MODE_1_5A);
+	case TCPC_TX_HARD_RESET:
+		cmd = USBC_TXCMD_HR;
 		break;
-	case USBC_RSLT_SRC_3_0A:
-		typec_set_pwr_opmode(wcove->port, TYPEC_PWR_MODE_3_0A);
+	case TCPC_TX_CABLE_RESET:
+		cmd = USBC_TXCMD_CR;
 		break;
-	case USBC_RSLT_SNK:
-		role = TYPEC_SOURCE;
+	case TCPC_TX_BIST_MODE_2:
+		cmd = USBC_TXCMD_BIST;
 		break;
-	case USBC_RSLT_DEBUG_ACC:
-		partner.accessory = TYPEC_ACCESSORY_DEBUG;
+	default:
+		return -EINVAL;
+	}
+
+	/* NOTE Setting maximum number of retries (7) */
+	ret = regmap_write(wcove->regmap, USBC_TXINFO,
+			   info | USBC_TXINFO_RETRIES(7));
+	if (ret)
+		return ret;
+
+	return regmap_write(wcove->regmap, USBC_TXCMD, cmd | USBC_TXCMD_START);
+}
+
+static int wcove_start_drp_toggling(struct tcpc_dev *tcpc,
+				    enum typec_cc_status cc)
+{
+	struct wcove_typec *wcove = tcpc_to_wcove(tcpc);
+	unsigned int usbc_ctrl;
+
+	usbc_ctrl = USBC_CONTROL1_MODE_DRP | USBC_CONTROL1_DRPTOGGLE_RANDOM;
+
+	switch (cc) {
+	case TYPEC_CC_RP_1_5:
+		usbc_ctrl |= USBC_CONTROL1_CURSRC_UA_180;
 		break;
-	case USBC_RSLT_AUDIO_ACC:
-		partner.accessory = TYPEC_ACCESSORY_AUDIO;
+	case TYPEC_CC_RP_3_0:
+		usbc_ctrl |= USBC_CONTROL1_CURSRC_UA_330;
 		break;
 	default:
-		dev_WARN(wcove->dev, "%s Undefined result\n", __func__);
-		goto err;
+		usbc_ctrl |= USBC_CONTROL1_CURSRC_UA_80;
+		break;
 	}
 
-	if (role == TYPEC_SINK) {
-		wcove_typec_func(wcove, WCOVE_FUNC_ROLE, WCOVE_ROLE_DEVICE);
-		typec_set_data_role(wcove->port, TYPEC_DEVICE);
-		typec_set_pwr_role(wcove->port, TYPEC_SINK);
-	} else {
-		wcove_typec_func(wcove, WCOVE_FUNC_ROLE, WCOVE_ROLE_HOST);
-		typec_set_pwr_role(wcove->port, TYPEC_SOURCE);
-		typec_set_data_role(wcove->port, TYPEC_HOST);
+	return regmap_write(wcove->regmap, USBC_CONTROL1, usbc_ctrl);
+}
+
+static int wcove_read_rx_buffer(struct wcove_typec *wcove, void *msg)
+{
+	unsigned int info;
+	int ret;
+	int i;
+
+	ret = regmap_read(wcove->regmap, USBC_RXINFO, &info);
+	if (ret)
+		return ret;
+
+	/* FIXME: Check that USBC_RXINFO_RXBYTES(info) matches the header */
+
+	for (i = 0; i < USBC_RXINFO_RXBYTES(info); i++) {
+		ret = regmap_read(wcove->regmap, USBC_RX_DATA + i, msg + i);
+		if (ret)
+			return ret;
 	}
 
-	wcove->partner = typec_register_partner(wcove->port, &partner);
-	if (!wcove->partner)
-		dev_err(wcove->dev, "failed register partner\n");
-out:
-	/* If either CC pins is requesting VCONN, we turn it on */
-	if ((cc1_ctrl & USBC_CC_CTRL_VCONN_EN) ||
-	    (cc2_ctrl &	USBC_CC_CTRL_VCONN_EN))
-		wcove_typec_func(wcove, WCOVE_FUNC_DRIVE_VCONN, true);
-	else
+	return regmap_write(wcove->regmap, USBC_RXSTATUS,
+			    USBC_RXSTATUS_RXCLEAR);
+}
+
+static irqreturn_t wcove_typec_irq(int irq, void *data)
+{
+	struct wcove_typec *wcove = data;
+	unsigned int usbc_irq1 = 0;
+	unsigned int usbc_irq2 = 0;
+	unsigned int cc1ctrl;
+	int ret;
+
+	mutex_lock(&wcove->lock);
+
+	/* Read.. */
+	ret = regmap_read(wcove->regmap, USBC_IRQ1, &usbc_irq1);
+	if (ret)
+		goto err;
+
+	ret = regmap_read(wcove->regmap, USBC_IRQ2, &usbc_irq2);
+	if (ret)
+		goto err;
+
+	ret = regmap_read(wcove->regmap, USBC_CC1_CTRL, &cc1ctrl);
+	if (ret)
+		goto err;
+
+	if (!wcove->tcpm)
+		goto err;
+
+	/* ..check.. */
+	if (usbc_irq1 & USBC_IRQ1_OVERTEMP) {
+		dev_err(wcove->dev, "VCONN Switch Over Temperature!\n");
 		wcove_typec_func(wcove, WCOVE_FUNC_DRIVE_VCONN, false);
+		/* REVISIT: Report an error? */
+	}
+
+	if (usbc_irq1 & USBC_IRQ1_SHORT) {
+		dev_err(wcove->dev, "VCONN Switch Short Circuit!\n");
+		wcove_typec_func(wcove, WCOVE_FUNC_DRIVE_VCONN, false);
+		/* REVISIT: Report an error? */
+	}
+
+	if (wcove->vbus != !!(cc1ctrl & USBC_CC_CTRL_VBUSOK))
+		tcpm_vbus_change(wcove->tcpm);
+
+	/* REVISIT: See if tcpm code can be made to consider Type-C HW FSMs */
+	if (usbc_irq2 & USBC_IRQ2_CC_CHANGE)
+		tcpm_cc_change(wcove->tcpm);
+
+	if (usbc_irq2 & USBC_IRQ2_RX_PD) {
+		unsigned int status;
+
+		/*
+		 * FIXME: Need to check if TX is ongoing and report
+		 * TX_DIREGARDED if needed?
+		 */
+
+		ret = regmap_read(wcove->regmap, USBC_RXSTATUS, &status);
+		if (ret)
+			goto err;
+
+		/* Flush all buffers */
+		while (status & USBC_RXSTATUS_RXDATA) {
+			struct pd_message msg;
+
+			ret = wcove_read_rx_buffer(wcove, &msg);
+			if (ret) {
+				dev_err(wcove->dev, "%s: RX read failed\n",
+					__func__);
+				goto err;
+			}
+
+			tcpm_pd_receive(wcove->tcpm, &msg);
+
+			ret = regmap_read(wcove->regmap, USBC_RXSTATUS,
+					  &status);
+			if (ret)
+				goto err;
+		}
+	}
+
+	if (usbc_irq2 & USBC_IRQ2_RX_HR)
+		tcpm_pd_hard_reset(wcove->tcpm);
+
+	/* REVISIT: if (usbc_irq2 & USBC_IRQ2_RX_CR) */
+
+	if (usbc_irq2 & USBC_IRQ2_TX_SUCCESS)
+		tcpm_pd_transmit_complete(wcove->tcpm, TCPC_TX_SUCCESS);
+
+	if (usbc_irq2 & USBC_IRQ2_TX_FAIL)
+		tcpm_pd_transmit_complete(wcove->tcpm, TCPC_TX_FAILED);
 
-	/* Relying on the FSM to know when we need to drive VBUS. */
-	wcove_typec_func(wcove, WCOVE_FUNC_DRIVE_VBUS,
-			 !!(status2 & USBC_STATUS2_VBUS_REQ));
 err:
+	/* ..and clear. */
+	if (usbc_irq1) {
+		ret = regmap_write(wcove->regmap, USBC_IRQ1, usbc_irq1);
+		if (ret)
+			dev_WARN(wcove->dev, "%s failed to clear IRQ1\n",
+				 __func__);
+	}
+
+	if (usbc_irq2) {
+		ret = regmap_write(wcove->regmap, USBC_IRQ2, usbc_irq2);
+		if (ret)
+			dev_WARN(wcove->dev, "%s failed to clear IRQ2\n",
+				 __func__);
+	}
+
 	/* REVISIT: Clear WhiskeyCove CHGR Type-C interrupt */
 	regmap_write(wcove->regmap, WCOVE_CHGRIRQ0, BIT(5));
 
@@ -288,11 +573,39 @@ static irqreturn_t wcove_typec_irq(int irq, void *data)
 	return IRQ_HANDLED;
 }
 
+/*
+ * The following power levels should be safe to use with Joule board.
+ */
+static const u32 src_pdo[] = {
+	PDO_FIXED(5000, 1500, PDO_FIXED_DUAL_ROLE | PDO_FIXED_DATA_SWAP |
+		  PDO_FIXED_USB_COMM),
+};
+
+static const u32 snk_pdo[] = {
+	PDO_FIXED(5000, 500, PDO_FIXED_DUAL_ROLE | PDO_FIXED_DATA_SWAP |
+		  PDO_FIXED_USB_COMM),
+};
+
+static struct tcpc_config wcove_typec_config = {
+	.src_pdo = src_pdo,
+	.nr_src_pdo = ARRAY_SIZE(src_pdo),
+	.snk_pdo = snk_pdo,
+	.nr_snk_pdo = ARRAY_SIZE(snk_pdo),
+
+	.max_snk_mv = 12000,
+	.max_snk_ma = 3000,
+	.max_snk_mw = 36000,
+	.operating_snk_mw = 15000,
+
+	.type = TYPEC_PORT_DRP,
+	.default_role = TYPEC_SINK,
+};
+
 static int wcove_typec_probe(struct platform_device *pdev)
 {
 	struct intel_soc_pmic *pmic = dev_get_drvdata(pdev->dev.parent);
 	struct wcove_typec *wcove;
-	unsigned int val;
+	int irq;
 	int ret;
 
 	wcove = devm_kzalloc(&pdev->dev, sizeof(*wcove), GFP_KERNEL);
@@ -303,43 +616,47 @@ static int wcove_typec_probe(struct platform_device *pdev)
 	wcove->dev = &pdev->dev;
 	wcove->regmap = pmic->regmap;
 
-	ret = regmap_irq_get_virq(pmic->irq_chip_data_chgr,
+	irq = regmap_irq_get_virq(pmic->irq_chip_data_chgr,
 				  platform_get_irq(pdev, 0));
-	if (ret < 0)
-		return ret;
+	if (irq < 0)
+		return irq;
 
-	ret = devm_request_threaded_irq(&pdev->dev, ret, NULL,
-					wcove_typec_irq, IRQF_ONESHOT,
-					"wcove_typec", wcove);
+	ret = guid_parse(WCOVE_DSM_UUID, &wcove->guid);
 	if (ret)
 		return ret;
 
-	if (!acpi_check_dsm(ACPI_HANDLE(&pdev->dev), &guid, 0, 0x1f)) {
+	if (!acpi_check_dsm(ACPI_HANDLE(&pdev->dev), &wcove->guid, 0, 0x1f)) {
 		dev_err(&pdev->dev, "Missing _DSM functions\n");
 		return -ENODEV;
 	}
 
-	wcove->cap.type = TYPEC_PORT_DRP;
-	wcove->cap.revision = USB_TYPEC_REV_1_1;
-	wcove->cap.prefer_role = TYPEC_NO_PREFERRED_ROLE;
+	wcove->tcpc.init = wcove_init;
+	wcove->tcpc.get_vbus = wcove_get_vbus;
+	wcove->tcpc.set_vbus = wcove_set_vbus;
+	wcove->tcpc.set_cc = wcove_set_cc;
+	wcove->tcpc.get_cc = wcove_get_cc;
+	wcove->tcpc.set_polarity = wcove_set_polarity;
+	wcove->tcpc.set_vconn = wcove_set_vconn;
+	wcove->tcpc.set_current_limit = wcove_set_current_limit;
+	wcove->tcpc.start_drp_toggling = wcove_start_drp_toggling;
 
-	/* Make sure the PD PHY is disabled until USB PD is available */
-	regmap_read(wcove->regmap, USBC_CONTROL3, &val);
-	regmap_write(wcove->regmap, USBC_CONTROL3, val | USBC_CONTROL3_PD_DIS);
+	wcove->tcpc.set_pd_rx = wcove_set_pd_rx;
+	wcove->tcpc.set_roles = wcove_set_roles;
+	wcove->tcpc.pd_transmit = wcove_pd_transmit;
 
-	/* DRP mode without accessory support */
-	regmap_read(wcove->regmap, USBC_CONTROL1, &val);
-	regmap_write(wcove->regmap, USBC_CONTROL1, USBC_CONTROL1_MODE_DRP(val));
+	wcove->tcpc.config = &wcove_typec_config;
 
-	wcove->port = typec_register_port(&pdev->dev, &wcove->cap);
-	if (!wcove->port)
-		return -ENODEV;
+	wcove->tcpm = tcpm_register_port(wcove->dev, &wcove->tcpc);
+	if (IS_ERR(wcove->tcpm))
+		return PTR_ERR(wcove->tcpm);
 
-	/* Unmask everything */
-	regmap_read(wcove->regmap, USBC_IRQMASK1, &val);
-	regmap_write(wcove->regmap, USBC_IRQMASK1, val & ~USBC_IRQMASK1_ALL);
-	regmap_read(wcove->regmap, USBC_IRQMASK2, &val);
-	regmap_write(wcove->regmap, USBC_IRQMASK2, val & ~USBC_IRQMASK2_ALL);
+	ret = devm_request_threaded_irq(&pdev->dev, irq, NULL,
+					wcove_typec_irq, IRQF_ONESHOT,
+					"wcove_typec", wcove);
+	if (ret) {
+		tcpm_unregister_port(wcove->tcpm);
+		return ret;
+	}
 
 	platform_set_drvdata(pdev, wcove);
 	return 0;
@@ -356,8 +673,8 @@ static int wcove_typec_remove(struct platform_device *pdev)
 	regmap_read(wcove->regmap, USBC_IRQMASK2, &val);
 	regmap_write(wcove->regmap, USBC_IRQMASK2, val | USBC_IRQMASK2_ALL);
 
-	typec_unregister_partner(wcove->partner);
-	typec_unregister_port(wcove->port);
+	tcpm_unregister_port(wcove->tcpm);
+
 	return 0;
 }
 
diff --git a/drivers/usb/typec/ucsi/Kconfig b/drivers/usb/typec/ucsi/Kconfig
index d0c31cee4720..e36d6c73c4a4 100644
--- a/drivers/usb/typec/ucsi/Kconfig
+++ b/drivers/usb/typec/ucsi/Kconfig
@@ -1,7 +1,6 @@
 config TYPEC_UCSI
 	tristate "USB Type-C Connector System Software Interface driver"
 	depends on !CPU_BIG_ENDIAN
-	select TYPEC
 	help
 	  USB Type-C Connector System Software Interface (UCSI) is a
 	  specification for an interface that allows the operating system to
diff --git a/drivers/usb/typec/ucsi/trace.c b/drivers/usb/typec/ucsi/trace.c
index 006f65c72a34..d9a6ff6e673c 100644
--- a/drivers/usb/typec/ucsi/trace.c
+++ b/drivers/usb/typec/ucsi/trace.c
@@ -1,2 +1,3 @@
+// SPDX-License-Identifier: GPL-2.0
 #define CREATE_TRACE_POINTS
 #include "trace.h"
diff --git a/drivers/usb/typec/ucsi/ucsi.c b/drivers/usb/typec/ucsi/ucsi.c
index 251f5d66651e..8d95b3a168d2 100644
--- a/drivers/usb/typec/ucsi/ucsi.c
+++ b/drivers/usb/typec/ucsi/ucsi.c
@@ -1,12 +1,9 @@
+// SPDX-License-Identifier: GPL-2.0
 /*
  * USB Type-C Connector System Software Interface driver
  *
  * Copyright (C) 2017, Intel Corporation
  * Author: Heikki Krogerus <heikki.krogerus@linux.intel.com>
- *
- * This program is free software; you can redistribute it and/or modify
- * it under the terms of the GNU General Public License version 2 as
- * published by the Free Software Foundation.
  */
 
 #include <linux/completion.h>
@@ -346,19 +343,6 @@ static void ucsi_connector_change(struct work_struct *work)
 	}
 
 	if (con->status.change & UCSI_CONSTAT_CONNECT_CHANGE) {
-		typec_set_pwr_role(con->port, con->status.pwr_dir);
-
-		switch (con->status.partner_type) {
-		case UCSI_CONSTAT_PARTNER_TYPE_UFP:
-			typec_set_data_role(con->port, TYPEC_HOST);
-			break;
-		case UCSI_CONSTAT_PARTNER_TYPE_DFP:
-			typec_set_data_role(con->port, TYPEC_DEVICE);
-			break;
-		default:
-			break;
-		}
-
 		if (con->status.connected)
 			ucsi_register_partner(con);
 		else
diff --git a/drivers/usb/typec/ucsi/ucsi_acpi.c b/drivers/usb/typec/ucsi/ucsi_acpi.c
index 494d2a49203a..44eb4e1ea817 100644
--- a/drivers/usb/typec/ucsi/ucsi_acpi.c
+++ b/drivers/usb/typec/ucsi/ucsi_acpi.c
@@ -1,12 +1,9 @@
+// SPDX-License-Identifier: GPL-2.0
 /*
  * UCSI ACPI driver
  *
  * Copyright (C) 2017, Intel Corporation
  * Author: Heikki Krogerus <heikki.krogerus@linux.intel.com>
- *
- * This program is free software; you can redistribute it and/or modify
- * it under the terms of the GNU General Public License version 2 as
- * published by the Free Software Foundation.
  */
 
 #include <linux/platform_device.h>
@@ -82,11 +79,6 @@ static int ucsi_acpi_probe(struct platform_device *pdev)
 		return -ENODEV;
 	}
 
-	/* This will make sure we can use ioremap_nocache() */
-	status = acpi_release_memory(ACPI_HANDLE(&pdev->dev), res, 1);
-	if (ACPI_FAILURE(status))
-		return -ENOMEM;
-
 	/*
 	 * NOTE: The memory region for the data structures is used also in an
 	 * operation region, which means ACPI has already reserved it. Therefore
diff --git a/drivers/staging/typec/pd.h b/include/linux/usb/pd.h
similarity index 98%
rename from drivers/staging/typec/pd.h
rename to include/linux/usb/pd.h
index 30b32ad72acd..b3d41d7409b3 100644
--- a/drivers/staging/typec/pd.h
+++ b/include/linux/usb/pd.h
@@ -104,6 +104,11 @@ static inline unsigned int pd_header_msgid_le(__le16 header)
 
 #define PD_MAX_PAYLOAD		7
 
+/**
+ * struct pd_message - PD message as seen on wire
+ * @header:	PD message header
+ * @payload:	PD message payload
+ */
 struct pd_message {
 	__le16 header;
 	__le32 payload[PD_MAX_PAYLOAD];
@@ -143,6 +148,8 @@ enum pd_pdo_type {
 	(PDO_TYPE(PDO_TYPE_FIXED) | (flags) |		\
 	 PDO_FIXED_VOLT(mv) | PDO_FIXED_CURR(ma))
 
+#define VSAFE5V 5000 /* mv units */
+
 #define PDO_BATT_MAX_VOLT_SHIFT	20	/* 50mV units */
 #define PDO_BATT_MIN_VOLT_SHIFT	10	/* 50mV units */
 #define PDO_BATT_MAX_PWR_SHIFT	0	/* 250mW units */
diff --git a/drivers/staging/typec/pd_bdo.h b/include/linux/usb/pd_bdo.h
similarity index 100%
rename from drivers/staging/typec/pd_bdo.h
rename to include/linux/usb/pd_bdo.h
diff --git a/drivers/staging/typec/pd_vdo.h b/include/linux/usb/pd_vdo.h
similarity index 99%
rename from drivers/staging/typec/pd_vdo.h
rename to include/linux/usb/pd_vdo.h
index d92259f8de0a..2b64d23ace5c 100644
--- a/drivers/staging/typec/pd_vdo.h
+++ b/include/linux/usb/pd_vdo.h
@@ -65,7 +65,7 @@
 #define CMD_EXIT_MODE		5
 #define CMD_ATTENTION		6
 
-#define VDO_CMD_VENDOR(x)    (((10 + (x)) & 0x1f))
+#define VDO_CMD_VENDOR(x)    (((0x10 + (x)) & 0x1f))
 
 /* ChromeOS specific commands */
 #define VDO_CMD_VERSION		VDO_CMD_VENDOR(0)
diff --git a/drivers/staging/typec/tcpm.h b/include/linux/usb/tcpm.h
similarity index 63%
rename from drivers/staging/typec/tcpm.h
rename to include/linux/usb/tcpm.h
index 7e9a6b7b5cd6..ca1c0b57f03f 100644
--- a/drivers/staging/typec/tcpm.h
+++ b/include/linux/usb/tcpm.h
@@ -54,6 +54,27 @@ enum tcpm_transmit_type {
 	TCPC_TX_BIST_MODE_2 = 7
 };
 
+/**
+ * struct tcpc_config - Port configuration
+ * @src_pdo:	PDO parameters sent to port partner as response to
+ *		PD_CTRL_GET_SOURCE_CAP message
+ * @nr_src_pdo:	Number of entries in @src_pdo
+ * @snk_pdo:	PDO parameters sent to partner as response to
+ *		PD_CTRL_GET_SINK_CAP message
+ * @nr_snk_pdo:	Number of entries in @snk_pdo
+ * @max_snk_mv:	Maximum acceptable sink voltage in mV
+ * @max_snk_ma:	Maximum sink current in mA
+ * @max_snk_mw:	Maximum required sink power in mW
+ * @operating_snk_mw:
+ *		Required operating sink power in mW
+ * @type:	Port type (TYPEC_PORT_DFP, TYPEC_PORT_UFP, or
+ *		TYPEC_PORT_DRP)
+ * @default_role:
+ *		Default port role (TYPEC_SINK or TYPEC_SOURCE).
+ *		Set to TYPEC_NO_PREFERRED_ROLE if no default role.
+ * @try_role_hw:True if try.{Src,Snk} is implemented in hardware
+ * @alt_modes:	List of supported alternate modes
+ */
 struct tcpc_config {
 	const u32 *src_pdo;
 	unsigned int nr_src_pdo;
@@ -79,7 +100,6 @@ struct tcpc_config {
 enum tcpc_usb_switch {
 	TCPC_USB_SWITCH_CONNECT,
 	TCPC_USB_SWITCH_DISCONNECT,
-	TCPC_USB_SWITCH_RESTORE,	/* TODO FIXME */
 };
 
 /* Mux state attributes */
@@ -104,17 +124,40 @@ struct tcpc_mux_dev {
 	void *priv_data;
 };
 
+/**
+ * struct tcpc_dev - Port configuration and callback functions
+ * @config:	Pointer to port configuration
+ * @get_vbus:	Called to read current VBUS state
+ * @get_current_limit:
+ *		Optional; called by the tcpm core when configured as a snk
+ *		and cc=Rp-def. This allows the tcpm to provide a fallback
+ *		current-limit detection method for the cc=Rp-def case.
+ *		For example, some tcpcs may include BC1.2 charger detection
+ *		and use that in this case.
+ * @set_cc:	Called to set value of CC pins
+ * @get_cc:	Called to read current CC pin values
+ * @set_polarity:
+ *		Called to set polarity
+ * @set_vconn:	Called to enable or disable VCONN
+ * @set_vbus:	Called to enable or disable VBUS
+ * @set_current_limit:
+ *		Optional; called to set current limit as negotiated
+ *		with partner.
+ * @set_pd_rx:	Called to enable or disable reception of PD messages
+ * @set_roles:	Called to set power and data roles
+ * @start_drp_toggling:
+ *		Optional; if supported by hardware, called to start DRP
+ *		toggling. DRP toggling is stopped automatically if
+ *		a connection is established.
+ * @try_role:	Optional; called to set a preferred role
+ * @pd_transmit:Called to transmit PD message
+ * @mux:	Pointer to multiplexer data
+ */
 struct tcpc_dev {
 	const struct tcpc_config *config;
 
 	int (*init)(struct tcpc_dev *dev);
 	int (*get_vbus)(struct tcpc_dev *dev);
-	/*
-	 * This optional callback gets called by the tcpm core when configured
-	 * as a snk and cc=Rp-def. This allows the tcpm to provide a fallback
-	 * current-limit detection method for the cc=Rp-def case. E.g. some
-	 * tcpcs may include BC1.2 charger detection and use that in this case.
-	 */
 	int (*get_current_limit)(struct tcpc_dev *dev);
 	int (*set_cc)(struct tcpc_dev *dev, enum typec_cc_status cc);
 	int (*get_cc)(struct tcpc_dev *dev, enum typec_cc_status *cc1,
@@ -140,14 +183,14 @@ struct tcpm_port;
 struct tcpm_port *tcpm_register_port(struct device *dev, struct tcpc_dev *tcpc);
 void tcpm_unregister_port(struct tcpm_port *port);
 
-void tcpm_update_source_capabilities(struct tcpm_port *port, const u32 *pdo,
-				     unsigned int nr_pdo);
-void tcpm_update_sink_capabilities(struct tcpm_port *port, const u32 *pdo,
-				   unsigned int nr_pdo,
-				   unsigned int max_snk_mv,
-				   unsigned int max_snk_ma,
-				   unsigned int max_snk_mw,
-				   unsigned int operating_snk_mw);
+int tcpm_update_source_capabilities(struct tcpm_port *port, const u32 *pdo,
+				    unsigned int nr_pdo);
+int tcpm_update_sink_capabilities(struct tcpm_port *port, const u32 *pdo,
+				  unsigned int nr_pdo,
+				  unsigned int max_snk_mv,
+				  unsigned int max_snk_ma,
+				  unsigned int max_snk_mw,
+				  unsigned int operating_snk_mw);
 
 void tcpm_vbus_change(struct tcpm_port *port);
 void tcpm_cc_change(struct tcpm_port *port);
-- 
2.23.0

