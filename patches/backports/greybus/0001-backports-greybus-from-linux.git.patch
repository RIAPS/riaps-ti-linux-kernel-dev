From 14382aafae026e5e1a877c5579d369d544e86d48 Mon Sep 17 00:00:00 2001
From: Robert Nelson <robertcnelson@gmail.com>
Date: Mon, 4 Nov 2019 12:01:17 -0600
Subject: [PATCH] backports: greybus: from: linux.git

Reference: v5.0.21
Signed-off-by: Robert Nelson <robertcnelson@gmail.com>
---
 drivers/staging/greybus/arche-apb-ctrl.c      |   1 -
 drivers/staging/greybus/arche_platform.h      |   2 +-
 drivers/staging/greybus/arpc.h                |   2 +-
 drivers/staging/greybus/audio_apbridgea.h     |   2 +-
 drivers/staging/greybus/audio_codec.c         |   1 -
 drivers/staging/greybus/audio_codec.h         |   2 +-
 drivers/staging/greybus/audio_manager.h       |   2 +-
 .../staging/greybus/audio_manager_module.c    |   4 +-
 .../staging/greybus/audio_manager_private.h   |   2 +-
 drivers/staging/greybus/audio_manager_sysfs.c |  22 +--
 drivers/staging/greybus/audio_module.c        |  20 +--
 drivers/staging/greybus/audio_topology.c      |  63 ++++----
 drivers/staging/greybus/bootrom.c             |  25 ++--
 drivers/staging/greybus/bundle.h              |   2 +-
 drivers/staging/greybus/camera.c              |  13 +-
 drivers/staging/greybus/connection.c          |  86 ++++++-----
 drivers/staging/greybus/connection.h          |   2 +-
 drivers/staging/greybus/control.c             |  53 +++----
 drivers/staging/greybus/control.h             |   4 +-
 drivers/staging/greybus/core.c                |   4 +-
 drivers/staging/greybus/es2.c                 |  74 +++++-----
 drivers/staging/greybus/gpio.c                |  39 ++---
 drivers/staging/greybus/greybus_protocols.h   |   8 +-
 drivers/staging/greybus/hid.c                 |  18 +--
 drivers/staging/greybus/i2c.c                 |  21 +--
 drivers/staging/greybus/loopback.c            |  68 +--------
 drivers/staging/greybus/module.c              |  19 ++-
 drivers/staging/greybus/operation.c           | 135 +++++++++---------
 drivers/staging/greybus/svc.c                 |  93 ++++++------
 drivers/staging/greybus/tools/README.loopback |   2 +-
 drivers/staging/greybus/tools/loopback_test.c |   2 +-
 drivers/staging/greybus/uart.c                |  47 +++---
 32 files changed, 386 insertions(+), 452 deletions(-)

diff --git a/drivers/staging/greybus/arche-apb-ctrl.c b/drivers/staging/greybus/arche-apb-ctrl.c
index cc8d6fc831b4..be5ffed90bcf 100644
--- a/drivers/staging/greybus/arche-apb-ctrl.c
+++ b/drivers/staging/greybus/arche-apb-ctrl.c
@@ -20,7 +20,6 @@
 #include <linux/spinlock.h>
 #include "arche_platform.h"
 
-
 static void apb_bootret_deassert(struct device *dev);
 
 struct arche_apb_ctrl_drvdata {
diff --git a/drivers/staging/greybus/arche_platform.h b/drivers/staging/greybus/arche_platform.h
index 02056351d25a..9d997f2d6517 100644
--- a/drivers/staging/greybus/arche_platform.h
+++ b/drivers/staging/greybus/arche_platform.h
@@ -1,4 +1,4 @@
-// SPDX-License-Identifier: GPL-2.0
+/* SPDX-License-Identifier: GPL-2.0 */
 /*
  * Arche Platform driver to enable Unipro link.
  *
diff --git a/drivers/staging/greybus/arpc.h b/drivers/staging/greybus/arpc.h
index 3534ba1a4e6c..3dab6375909c 100644
--- a/drivers/staging/greybus/arpc.h
+++ b/drivers/staging/greybus/arpc.h
@@ -1,4 +1,4 @@
-// SPDX-License-Identifier: (GPL-2.0 OR BSD-3-Clause)
+/* SPDX-License-Identifier: (GPL-2.0 OR BSD-3-Clause) */
 /*
  * This file is provided under a dual BSD/GPLv2 license.  When using or
  * redistributing this file, you may do so under either license.
diff --git a/drivers/staging/greybus/audio_apbridgea.h b/drivers/staging/greybus/audio_apbridgea.h
index 42ac6059bfc7..330fc7a397eb 100644
--- a/drivers/staging/greybus/audio_apbridgea.h
+++ b/drivers/staging/greybus/audio_apbridgea.h
@@ -1,4 +1,4 @@
-// SPDX-License-Identifier: BSD-3-Clause
+/* SPDX-License-Identifier: BSD-3-Clause */
 /**
  * Copyright (c) 2015-2016 Google Inc.
  * All rights reserved.
diff --git a/drivers/staging/greybus/audio_codec.c b/drivers/staging/greybus/audio_codec.c
index 35acd55ca5ab..08746c85dea6 100644
--- a/drivers/staging/greybus/audio_codec.c
+++ b/drivers/staging/greybus/audio_codec.c
@@ -1087,7 +1087,6 @@ static const struct of_device_id greybus_asoc_machine_of_match[]  = {
 static struct platform_driver gbaudio_codec_driver = {
 	.driver = {
 		.name = "apb-dummy-codec",
-		.owner = THIS_MODULE,
 #ifdef CONFIG_PM
 		.pm = &gbaudio_codec_pm_ops,
 #endif
diff --git a/drivers/staging/greybus/audio_codec.h b/drivers/staging/greybus/audio_codec.h
index 4efd8b3ebe07..d36f8cd35e06 100644
--- a/drivers/staging/greybus/audio_codec.h
+++ b/drivers/staging/greybus/audio_codec.h
@@ -1,4 +1,4 @@
-// SPDX-License-Identifier: GPL-2.0
+/* SPDX-License-Identifier: GPL-2.0 */
 /*
  * Greybus audio driver
  * Copyright 2015 Google Inc.
diff --git a/drivers/staging/greybus/audio_manager.h b/drivers/staging/greybus/audio_manager.h
index dcb1a20f5ff1..be605485a8ce 100644
--- a/drivers/staging/greybus/audio_manager.h
+++ b/drivers/staging/greybus/audio_manager.h
@@ -1,4 +1,4 @@
-// SPDX-License-Identifier: GPL-2.0
+/* SPDX-License-Identifier: GPL-2.0 */
 /*
  * Greybus operations
  *
diff --git a/drivers/staging/greybus/audio_manager_module.c b/drivers/staging/greybus/audio_manager_module.c
index 52342e832e3b..2bfd804183c4 100644
--- a/drivers/staging/greybus/audio_manager_module.c
+++ b/drivers/staging/greybus/audio_manager_module.c
@@ -25,8 +25,8 @@ struct gb_audio_manager_module_attribute {
 			 const char *buf, size_t count);
 };
 
-static ssize_t gb_audio_module_attr_show(
-	struct kobject *kobj, struct attribute *attr, char *buf)
+static ssize_t gb_audio_module_attr_show(struct kobject *kobj,
+					 struct attribute *attr, char *buf)
 {
 	struct gb_audio_manager_module_attribute *attribute;
 	struct gb_audio_manager_module *module;
diff --git a/drivers/staging/greybus/audio_manager_private.h b/drivers/staging/greybus/audio_manager_private.h
index 9d9b58fc54c4..2b3a766c7de7 100644
--- a/drivers/staging/greybus/audio_manager_private.h
+++ b/drivers/staging/greybus/audio_manager_private.h
@@ -1,4 +1,4 @@
-// SPDX-License-Identifier: GPL-2.0
+/* SPDX-License-Identifier: GPL-2.0 */
 /*
  * Greybus operations
  *
diff --git a/drivers/staging/greybus/audio_manager_sysfs.c b/drivers/staging/greybus/audio_manager_sysfs.c
index 283fbed0c8ed..ab882cc49b41 100644
--- a/drivers/staging/greybus/audio_manager_sysfs.c
+++ b/drivers/staging/greybus/audio_manager_sysfs.c
@@ -11,9 +11,9 @@
 #include "audio_manager.h"
 #include "audio_manager_private.h"
 
-static ssize_t manager_sysfs_add_store(
-	struct kobject *kobj, struct kobj_attribute *attr,
-	const char *buf, size_t count)
+static ssize_t manager_sysfs_add_store(struct kobject *kobj,
+				       struct kobj_attribute *attr,
+				       const char *buf, size_t count)
 {
 	struct gb_audio_manager_module_descriptor desc = { {0} };
 
@@ -36,9 +36,9 @@ static ssize_t manager_sysfs_add_store(
 static struct kobj_attribute manager_add_attribute =
 	__ATTR(add, 0664, NULL, manager_sysfs_add_store);
 
-static ssize_t manager_sysfs_remove_store(
-	struct kobject *kobj, struct kobj_attribute *attr,
-	const char *buf, size_t count)
+static ssize_t manager_sysfs_remove_store(struct kobject *kobj,
+					  struct kobj_attribute *attr,
+					  const char *buf, size_t count)
 {
 	int id;
 
@@ -57,9 +57,9 @@ static ssize_t manager_sysfs_remove_store(
 static struct kobj_attribute manager_remove_attribute =
 	__ATTR(remove, 0664, NULL, manager_sysfs_remove_store);
 
-static ssize_t manager_sysfs_dump_store(
-	struct kobject *kobj, struct kobj_attribute *attr,
-	const char *buf, size_t count)
+static ssize_t manager_sysfs_dump_store(struct kobject *kobj,
+					struct kobj_attribute *attr,
+					const char *buf, size_t count)
 {
 	int id;
 
@@ -81,8 +81,8 @@ static ssize_t manager_sysfs_dump_store(
 static struct kobj_attribute manager_dump_attribute =
 	__ATTR(dump, 0664, NULL, manager_sysfs_dump_store);
 
-static void manager_sysfs_init_attribute(
-		struct kobject *kobj, struct kobj_attribute *kattr)
+static void manager_sysfs_init_attribute(struct kobject *kobj,
+					 struct kobj_attribute *kattr)
 {
 	int err;
 
diff --git a/drivers/staging/greybus/audio_module.c b/drivers/staging/greybus/audio_module.c
index d065334efa23..300a2b4f3fc7 100644
--- a/drivers/staging/greybus/audio_module.c
+++ b/drivers/staging/greybus/audio_module.c
@@ -18,7 +18,7 @@
  */
 
 static int gbaudio_request_jack(struct gbaudio_module_info *module,
-				  struct gb_audio_jack_event_request *req)
+				struct gb_audio_jack_event_request *req)
 {
 	int report;
 	struct snd_jack *jack = module->headset_jack.jack;
@@ -26,8 +26,8 @@ static int gbaudio_request_jack(struct gbaudio_module_info *module,
 
 	if (!jack) {
 		dev_err_ratelimited(module->dev,
-			"Invalid jack event received:type: %u, event: %u\n",
-			req->jack_attribute, req->event);
+				    "Invalid jack event received:type: %u, event: %u\n",
+				    req->jack_attribute, req->event);
 		return -EINVAL;
 	}
 
@@ -50,8 +50,8 @@ static int gbaudio_request_jack(struct gbaudio_module_info *module,
 	report = req->jack_attribute & module->jack_mask;
 	if (!report) {
 		dev_err_ratelimited(module->dev,
-			"Invalid jack event received:type: %u, event: %u\n",
-			req->jack_attribute, req->event);
+				    "Invalid jack event received:type: %u, event: %u\n",
+				    req->jack_attribute, req->event);
 		return -EINVAL;
 	}
 
@@ -74,8 +74,8 @@ static int gbaudio_request_button(struct gbaudio_module_info *module,
 
 	if (!btn_jack) {
 		dev_err_ratelimited(module->dev,
-			"Invalid button event received:type: %u, event: %u\n",
-			req->button_id, req->event);
+				    "Invalid button event received:type: %u, event: %u\n",
+				    req->button_id, req->event);
 		return -EINVAL;
 	}
 
@@ -210,8 +210,8 @@ static int gb_audio_add_data_connection(struct gbaudio_module_info *gbmodule,
 		return -ENOMEM;
 
 	connection = gb_connection_create_offloaded(bundle,
-					le16_to_cpu(cport_desc->id),
-					GB_CONNECTION_FLAG_CSD);
+						    le16_to_cpu(cport_desc->id),
+						    GB_CONNECTION_FLAG_CSD);
 	if (IS_ERR(connection)) {
 		devm_kfree(gbmodule->dev, dai);
 		return PTR_ERR(connection);
@@ -317,7 +317,7 @@ static int gb_audio_probe(struct gb_bundle *bundle,
 	ret = gbaudio_tplg_parse_data(gbmodule, topology);
 	if (ret) {
 		dev_err(dev, "%d:Error while parsing topology data\n",
-			  ret);
+			ret);
 		goto free_topology;
 	}
 	gbmodule->topology = topology;
diff --git a/drivers/staging/greybus/audio_topology.c b/drivers/staging/greybus/audio_topology.c
index b71078339e86..8bcbc3c4588c 100644
--- a/drivers/staging/greybus/audio_topology.c
+++ b/drivers/staging/greybus/audio_topology.c
@@ -158,7 +158,7 @@ static const char **gb_generate_enum_strings(struct gbaudio_module_info *gb,
 }
 
 static int gbcodec_mixer_ctl_info(struct snd_kcontrol *kcontrol,
-		     struct snd_ctl_elem_info *uinfo)
+				  struct snd_ctl_elem_info *uinfo)
 {
 	unsigned int max;
 	const char *name;
@@ -209,7 +209,7 @@ static int gbcodec_mixer_ctl_info(struct snd_kcontrol *kcontrol,
 }
 
 static int gbcodec_mixer_ctl_get(struct snd_kcontrol *kcontrol,
-	struct snd_ctl_elem_value *ucontrol)
+				 struct snd_ctl_elem_value *ucontrol)
 {
 	int ret;
 	struct gb_audio_ctl_elem_info *info;
@@ -271,7 +271,7 @@ static int gbcodec_mixer_ctl_get(struct snd_kcontrol *kcontrol,
 }
 
 static int gbcodec_mixer_ctl_put(struct snd_kcontrol *kcontrol,
-			      struct snd_ctl_elem_value *ucontrol)
+				 struct snd_ctl_elem_value *ucontrol)
 {
 	int ret = 0;
 	struct gb_audio_ctl_elem_info *info;
@@ -347,7 +347,7 @@ static int gbcodec_mixer_ctl_put(struct snd_kcontrol *kcontrol,
  * of DAPM related sequencing, etc.
  */
 static int gbcodec_mixer_dapm_ctl_info(struct snd_kcontrol *kcontrol,
-		     struct snd_ctl_elem_info *uinfo)
+				       struct snd_ctl_elem_info *uinfo)
 {
 	int platform_max, platform_min;
 	struct gbaudio_ctl_pvt *data;
@@ -378,7 +378,7 @@ static int gbcodec_mixer_dapm_ctl_info(struct snd_kcontrol *kcontrol,
 }
 
 static int gbcodec_mixer_dapm_ctl_get(struct snd_kcontrol *kcontrol,
-	struct snd_ctl_elem_value *ucontrol)
+				      struct snd_ctl_elem_value *ucontrol)
 {
 	int ret;
 	struct gb_audio_ctl_elem_info *info;
@@ -427,7 +427,7 @@ static int gbcodec_mixer_dapm_ctl_get(struct snd_kcontrol *kcontrol,
 }
 
 static int gbcodec_mixer_dapm_ctl_put(struct snd_kcontrol *kcontrol,
-			      struct snd_ctl_elem_value *ucontrol)
+				      struct snd_ctl_elem_value *ucontrol)
 {
 	int ret, wi, max, connect;
 	unsigned int mask, val;
@@ -501,7 +501,7 @@ static int gbcodec_mixer_dapm_ctl_put(struct snd_kcontrol *kcontrol,
 	.private_value = (unsigned long)data}
 
 static int gbcodec_event_spk(struct snd_soc_dapm_widget *w,
-					struct snd_kcontrol *k, int event)
+			     struct snd_kcontrol *k, int event)
 {
 	/* Ensure GB speaker is connected */
 
@@ -509,7 +509,7 @@ static int gbcodec_event_spk(struct snd_soc_dapm_widget *w,
 }
 
 static int gbcodec_event_hp(struct snd_soc_dapm_widget *w,
-					struct snd_kcontrol *k, int event)
+			    struct snd_kcontrol *k, int event)
 {
 	/* Ensure GB module supports jack slot */
 
@@ -517,7 +517,7 @@ static int gbcodec_event_hp(struct snd_soc_dapm_widget *w,
 }
 
 static int gbcodec_event_int_mic(struct snd_soc_dapm_widget *w,
-					struct snd_kcontrol *k, int event)
+				 struct snd_kcontrol *k, int event)
 {
 	/* Ensure GB module supports jack slot */
 
@@ -664,7 +664,7 @@ static int gbaudio_tplg_create_enum_kctl(struct gbaudio_module_info *gb,
 
 	/* debug enum info */
 	dev_dbg(gb->dev, "Max:%d, name_length:%d\n", gbe->max,
-		 le16_to_cpu(gb_enum->names_length));
+		le16_to_cpu(gb_enum->names_length));
 	for (i = 0; i < gbe->max; i++)
 		dev_dbg(gb->dev, "src[%d]: %s\n", i, gbe->texts[i]);
 
@@ -873,7 +873,7 @@ static int gbaudio_tplg_create_enum_ctl(struct gbaudio_module_info *gb,
 
 	/* debug enum info */
 	dev_dbg(gb->dev, "Max:%d, name_length:%d\n", gbe->max,
-		 le16_to_cpu(gb_enum->names_length));
+		le16_to_cpu(gb_enum->names_length));
 	for (i = 0; i < gbe->max; i++)
 		dev_dbg(gb->dev, "src[%d]: %s\n", i, gbe->texts[i]);
 
@@ -884,8 +884,8 @@ static int gbaudio_tplg_create_enum_ctl(struct gbaudio_module_info *gb,
 }
 
 static int gbaudio_tplg_create_mixer_ctl(struct gbaudio_module_info *gb,
-					     struct snd_kcontrol_new *kctl,
-					     struct gb_audio_control *ctl)
+					 struct snd_kcontrol_new *kctl,
+					 struct gb_audio_control *ctl)
 {
 	struct gbaudio_ctl_pvt *ctldata;
 
@@ -905,8 +905,8 @@ static int gbaudio_tplg_create_mixer_ctl(struct gbaudio_module_info *gb,
 }
 
 static int gbaudio_tplg_create_wcontrol(struct gbaudio_module_info *gb,
-					     struct snd_kcontrol_new *kctl,
-					     struct gb_audio_control *ctl)
+					struct snd_kcontrol_new *kctl,
+					struct gb_audio_control *ctl)
 {
 	int ret;
 
@@ -1086,9 +1086,10 @@ static int gbaudio_tplg_create_widget(struct gbaudio_module_info *module,
 	case snd_soc_dapm_switch:
 		*dw = (struct snd_soc_dapm_widget)
 			SND_SOC_DAPM_SWITCH_E(w->name, SND_SOC_NOPM, 0, 0,
-					    widget_kctls, gbaudio_widget_event,
-					    SND_SOC_DAPM_PRE_PMU |
-					    SND_SOC_DAPM_POST_PMD);
+					      widget_kctls,
+					      gbaudio_widget_event,
+					      SND_SOC_DAPM_PRE_PMU |
+					      SND_SOC_DAPM_POST_PMD);
 		break;
 	case snd_soc_dapm_pga:
 		*dw = (struct snd_soc_dapm_widget)
@@ -1100,16 +1101,16 @@ static int gbaudio_tplg_create_widget(struct gbaudio_module_info *module,
 	case snd_soc_dapm_mixer:
 		*dw = (struct snd_soc_dapm_widget)
 			SND_SOC_DAPM_MIXER_E(w->name, SND_SOC_NOPM, 0, 0, NULL,
-					   0, gbaudio_widget_event,
-					   SND_SOC_DAPM_PRE_PMU |
-					   SND_SOC_DAPM_POST_PMD);
+					     0, gbaudio_widget_event,
+					     SND_SOC_DAPM_PRE_PMU |
+					     SND_SOC_DAPM_POST_PMD);
 		break;
 	case snd_soc_dapm_mux:
 		*dw = (struct snd_soc_dapm_widget)
 			SND_SOC_DAPM_MUX_E(w->name, SND_SOC_NOPM, 0, 0,
-					 widget_kctls, gbaudio_widget_event,
-					 SND_SOC_DAPM_PRE_PMU |
-					 SND_SOC_DAPM_POST_PMD);
+					   widget_kctls, gbaudio_widget_event,
+					   SND_SOC_DAPM_PRE_PMU |
+					   SND_SOC_DAPM_POST_PMD);
 		break;
 	case snd_soc_dapm_aif_in:
 		*dw = (struct snd_soc_dapm_widget)
@@ -1145,7 +1146,7 @@ static int gbaudio_tplg_create_widget(struct gbaudio_module_info *module,
 }
 
 static int gbaudio_tplg_process_kcontrols(struct gbaudio_module_info *module,
-				   struct gb_audio_control *controls)
+					  struct gb_audio_control *controls)
 {
 	int i, csize, ret;
 	struct snd_kcontrol_new *dapm_kctls;
@@ -1215,7 +1216,7 @@ static int gbaudio_tplg_process_kcontrols(struct gbaudio_module_info *module,
 }
 
 static int gbaudio_tplg_process_widgets(struct gbaudio_module_info *module,
-				   struct gb_audio_widget *widgets)
+					struct gb_audio_widget *widgets)
 {
 	int i, ret, w_size;
 	struct snd_soc_dapm_widget *dapm_widgets;
@@ -1264,7 +1265,7 @@ static int gbaudio_tplg_process_widgets(struct gbaudio_module_info *module,
 }
 
 static int gbaudio_tplg_process_routes(struct gbaudio_module_info *module,
-				   struct gb_audio_route *routes)
+				       struct gb_audio_route *routes)
 {
 	int i, ret;
 	struct snd_soc_dapm_route *dapm_routes;
@@ -1300,8 +1301,8 @@ static int gbaudio_tplg_process_routes(struct gbaudio_module_info *module,
 		}
 		dapm_routes->control =
 			gbaudio_map_controlid(module,
-						      curr->control_id,
-						      curr->index);
+					      curr->control_id,
+					      curr->index);
 		if ((curr->control_id !=  GBAUDIO_INVALID_ID) &&
 		    !dapm_routes->control) {
 			dev_err(module->dev, "%d:%d:%d:%d - Invalid control\n",
@@ -1325,7 +1326,7 @@ static int gbaudio_tplg_process_routes(struct gbaudio_module_info *module,
 }
 
 static int gbaudio_tplg_process_header(struct gbaudio_module_info *module,
-				 struct gb_audio_topology *tplg_data)
+				       struct gb_audio_topology *tplg_data)
 {
 	/* fetch no. of kcontrols, widgets & routes */
 	module->num_controls = tplg_data->num_controls;
@@ -1351,7 +1352,7 @@ static int gbaudio_tplg_process_header(struct gbaudio_module_info *module,
 }
 
 int gbaudio_tplg_parse_data(struct gbaudio_module_info *module,
-			       struct gb_audio_topology *tplg_data)
+			    struct gb_audio_topology *tplg_data)
 {
 	int ret;
 	struct gb_audio_control *controls;
diff --git a/drivers/staging/greybus/bootrom.c b/drivers/staging/greybus/bootrom.c
index e85ffae85dff..402e6360834f 100644
--- a/drivers/staging/greybus/bootrom.c
+++ b/drivers/staging/greybus/bootrom.c
@@ -86,7 +86,8 @@ static void gb_bootrom_timedout(struct work_struct *work)
 }
 
 static void gb_bootrom_set_timeout(struct gb_bootrom *bootrom,
-			enum next_request_type next, unsigned long timeout)
+				   enum next_request_type next,
+				   unsigned long timeout)
 {
 	bootrom->next_request = next;
 	schedule_delayed_work(&bootrom->dwork, msecs_to_jiffies(timeout));
@@ -175,7 +176,7 @@ static int find_firmware(struct gb_bootrom *bootrom, u8 stage)
 		 firmware_name);
 
 	rc = request_firmware(&bootrom->fw, firmware_name,
-		&connection->bundle->dev);
+			      &connection->bundle->dev);
 	if (rc) {
 		dev_err(&connection->bundle->dev,
 			"failed to find %s firmware (%d)\n", firmware_name, rc);
@@ -274,7 +275,7 @@ static int gb_bootrom_get_firmware(struct gb_operation *op)
 
 	if (offset >= fw->size || size > fw->size - offset) {
 		dev_warn(dev, "bad firmware request (offs = %u, size = %u)\n",
-				offset, size);
+			 offset, size);
 		ret = -EINVAL;
 		goto unlock;
 	}
@@ -387,15 +388,15 @@ static int gb_bootrom_get_version(struct gb_bootrom *bootrom)
 				sizeof(response));
 	if (ret) {
 		dev_err(&bundle->dev,
-				"failed to get protocol version: %d\n",
-				ret);
+			"failed to get protocol version: %d\n",
+			ret);
 		return ret;
 	}
 
 	if (response.major > request.major) {
 		dev_err(&bundle->dev,
-				"unsupported major protocol version (%u > %u)\n",
-				response.major, request.major);
+			"unsupported major protocol version (%u > %u)\n",
+			response.major, request.major);
 		return -ENOTSUPP;
 	}
 
@@ -403,13 +404,13 @@ static int gb_bootrom_get_version(struct gb_bootrom *bootrom)
 	bootrom->protocol_minor = response.minor;
 
 	dev_dbg(&bundle->dev, "%s - %u.%u\n", __func__, response.major,
-			response.minor);
+		response.minor);
 
 	return 0;
 }
 
 static int gb_bootrom_probe(struct gb_bundle *bundle,
-					const struct greybus_bundle_id *id)
+			    const struct greybus_bundle_id *id)
 {
 	struct greybus_descriptor_cport *cport_desc;
 	struct gb_connection *connection;
@@ -428,8 +429,8 @@ static int gb_bootrom_probe(struct gb_bundle *bundle,
 		return -ENOMEM;
 
 	connection = gb_connection_create(bundle,
-						le16_to_cpu(cport_desc->id),
-						gb_bootrom_request_handler);
+					  le16_to_cpu(cport_desc->id),
+					  gb_bootrom_request_handler);
 	if (IS_ERR(connection)) {
 		ret = PTR_ERR(connection);
 		goto err_free_bootrom;
@@ -466,7 +467,7 @@ static int gb_bootrom_probe(struct gb_bundle *bundle,
 				NULL, 0);
 	if (ret) {
 		dev_err(&connection->bundle->dev,
-				"failed to send AP READY: %d\n", ret);
+			"failed to send AP READY: %d\n", ret);
 		goto err_cancel_timeout;
 	}
 
diff --git a/drivers/staging/greybus/bundle.h b/drivers/staging/greybus/bundle.h
index ffcfd43802cc..8734d2055657 100644
--- a/drivers/staging/greybus/bundle.h
+++ b/drivers/staging/greybus/bundle.h
@@ -1,4 +1,4 @@
-// SPDX-License-Identifier: GPL-2.0
+/* SPDX-License-Identifier: GPL-2.0 */
 /*
  * Greybus bundles
  *
diff --git a/drivers/staging/greybus/camera.c b/drivers/staging/greybus/camera.c
index 6dded10f4155..615c8e7fd51e 100644
--- a/drivers/staging/greybus/camera.c
+++ b/drivers/staging/greybus/camera.c
@@ -841,8 +841,8 @@ static int gb_camera_op_configure_streams(void *priv, unsigned int *nstreams,
 }
 
 static int gb_camera_op_capture(void *priv, u32 request_id,
-		unsigned int streams, unsigned int num_frames,
-		size_t settings_size, const void *settings)
+				unsigned int streams, unsigned int num_frames,
+				size_t settings_size, const void *settings)
 {
 	struct gb_camera *gcam = priv;
 
@@ -869,7 +869,7 @@ static const struct gb_camera_ops gb_cam_ops = {
  */
 
 static ssize_t gb_camera_debugfs_capabilities(struct gb_camera *gcam,
-		char *buf, size_t len)
+					      char *buf, size_t len)
 {
 	struct gb_camera_debugfs_buffer *buffer =
 		&gcam->debugfs.buffers[GB_CAMERA_DEBUGFS_BUFFER_CAPABILITIES];
@@ -905,7 +905,7 @@ static ssize_t gb_camera_debugfs_capabilities(struct gb_camera *gcam,
 }
 
 static ssize_t gb_camera_debugfs_configure_streams(struct gb_camera *gcam,
-		char *buf, size_t len)
+						   char *buf, size_t len)
 {
 	struct gb_camera_debugfs_buffer *buffer =
 		&gcam->debugfs.buffers[GB_CAMERA_DEBUGFS_BUFFER_STREAMS];
@@ -999,7 +999,7 @@ static ssize_t gb_camera_debugfs_configure_streams(struct gb_camera *gcam,
 };
 
 static ssize_t gb_camera_debugfs_capture(struct gb_camera *gcam,
-		char *buf, size_t len)
+					 char *buf, size_t len)
 {
 	unsigned int request_id;
 	unsigned int streams_mask;
@@ -1040,7 +1040,7 @@ static ssize_t gb_camera_debugfs_capture(struct gb_camera *gcam,
 }
 
 static ssize_t gb_camera_debugfs_flush(struct gb_camera *gcam,
-		char *buf, size_t len)
+				       char *buf, size_t len)
 {
 	struct gb_camera_debugfs_buffer *buffer =
 		&gcam->debugfs.buffers[GB_CAMERA_DEBUGFS_BUFFER_FLUSH];
@@ -1190,7 +1190,6 @@ static int gb_camera_debugfs_init(struct gb_camera *gcam)
 		debugfs_create_file(entry->name, entry->mask,
 				    gcam->debugfs.root, gcam,
 				    &gb_camera_debugfs_ops);
-		}
 	}
 
 	return 0;
diff --git a/drivers/staging/greybus/connection.c b/drivers/staging/greybus/connection.c
index 2103168b585e..eda964208cce 100644
--- a/drivers/staging/greybus/connection.c
+++ b/drivers/staging/greybus/connection.c
@@ -11,17 +11,13 @@
 #include "greybus.h"
 #include "greybus_trace.h"
 
-
 #define GB_CONNECTION_CPORT_QUIESCE_TIMEOUT	1000
 
-
 static void gb_connection_kref_release(struct kref *kref);
 
-
 static DEFINE_SPINLOCK(gb_connections_lock);
 static DEFINE_MUTEX(gb_connection_mutex);
 
-
 /* Caller holds gb_connection_mutex. */
 static bool gb_connection_cport_in_use(struct gb_interface *intf, u16 cport_id)
 {
@@ -30,7 +26,7 @@ static bool gb_connection_cport_in_use(struct gb_interface *intf, u16 cport_id)
 
 	list_for_each_entry(connection, &hd->connections, hd_links) {
 		if (connection->intf == intf &&
-				connection->intf_cport_id == cport_id)
+		    connection->intf_cport_id == cport_id)
 			return true;
 	}
 
@@ -78,7 +74,7 @@ gb_connection_hd_find(struct gb_host_device *hd, u16 cport_id)
  * received on the bundle.
  */
 void greybus_data_rcvd(struct gb_host_device *hd, u16 cport_id,
-			u8 *data, size_t length)
+		       u8 *data, size_t length)
 {
 	struct gb_connection *connection;
 
@@ -118,7 +114,7 @@ static void gb_connection_init_name(struct gb_connection *connection)
 	}
 
 	snprintf(connection->name, sizeof(connection->name),
-			"%u/%u:%u", hd_cport_id, intf_id, cport_id);
+		 "%u/%u:%u", hd_cport_id, intf_id, cport_id);
 }
 
 /*
@@ -146,10 +142,10 @@ static void gb_connection_init_name(struct gb_connection *connection)
  */
 static struct gb_connection *
 _gb_connection_create(struct gb_host_device *hd, int hd_cport_id,
-				struct gb_interface *intf,
-				struct gb_bundle *bundle, int cport_id,
-				gb_request_handler_t handler,
-				unsigned long flags)
+		      struct gb_interface *intf,
+		      struct gb_bundle *bundle, int cport_id,
+		      gb_request_handler_t handler,
+		      unsigned long flags)
 {
 	struct gb_connection *connection;
 	int ret;
@@ -230,35 +226,35 @@ _gb_connection_create(struct gb_host_device *hd, int hd_cport_id,
 
 struct gb_connection *
 gb_connection_create_static(struct gb_host_device *hd, u16 hd_cport_id,
-					gb_request_handler_t handler)
+			    gb_request_handler_t handler)
 {
 	return _gb_connection_create(hd, hd_cport_id, NULL, NULL, 0, handler,
-					GB_CONNECTION_FLAG_HIGH_PRIO);
+				     GB_CONNECTION_FLAG_HIGH_PRIO);
 }
 
 struct gb_connection *
 gb_connection_create_control(struct gb_interface *intf)
 {
 	return _gb_connection_create(intf->hd, -1, intf, NULL, 0, NULL,
-					GB_CONNECTION_FLAG_CONTROL |
-					GB_CONNECTION_FLAG_HIGH_PRIO);
+				     GB_CONNECTION_FLAG_CONTROL |
+				     GB_CONNECTION_FLAG_HIGH_PRIO);
 }
 
 struct gb_connection *
 gb_connection_create(struct gb_bundle *bundle, u16 cport_id,
-					gb_request_handler_t handler)
+		     gb_request_handler_t handler)
 {
 	struct gb_interface *intf = bundle->intf;
 
 	return _gb_connection_create(intf->hd, -1, intf, bundle, cport_id,
-					handler, 0);
+				     handler, 0);
 }
 EXPORT_SYMBOL_GPL(gb_connection_create);
 
 struct gb_connection *
 gb_connection_create_flags(struct gb_bundle *bundle, u16 cport_id,
-					gb_request_handler_t handler,
-					unsigned long flags)
+			   gb_request_handler_t handler,
+			   unsigned long flags)
 {
 	struct gb_interface *intf = bundle->intf;
 
@@ -266,13 +262,13 @@ gb_connection_create_flags(struct gb_bundle *bundle, u16 cport_id,
 		flags &= ~GB_CONNECTION_FLAG_CORE_MASK;
 
 	return _gb_connection_create(intf->hd, -1, intf, bundle, cport_id,
-					handler, flags);
+				     handler, flags);
 }
 EXPORT_SYMBOL_GPL(gb_connection_create_flags);
 
 struct gb_connection *
 gb_connection_create_offloaded(struct gb_bundle *bundle, u16 cport_id,
-					unsigned long flags)
+			       unsigned long flags)
 {
 	flags |= GB_CONNECTION_FLAG_OFFLOADED;
 
@@ -289,10 +285,10 @@ static int gb_connection_hd_cport_enable(struct gb_connection *connection)
 		return 0;
 
 	ret = hd->driver->cport_enable(hd, connection->hd_cport_id,
-					connection->flags);
+				       connection->flags);
 	if (ret) {
 		dev_err(&hd->dev, "%s: failed to enable host cport: %d\n",
-				connection->name, ret);
+			connection->name, ret);
 		return ret;
 	}
 
@@ -310,7 +306,7 @@ static void gb_connection_hd_cport_disable(struct gb_connection *connection)
 	ret = hd->driver->cport_disable(hd, connection->hd_cport_id);
 	if (ret) {
 		dev_err(&hd->dev, "%s: failed to disable host cport: %d\n",
-				connection->name, ret);
+			connection->name, ret);
 	}
 }
 
@@ -325,7 +321,7 @@ static int gb_connection_hd_cport_connected(struct gb_connection *connection)
 	ret = hd->driver->cport_connected(hd, connection->hd_cport_id);
 	if (ret) {
 		dev_err(&hd->dev, "%s: failed to set connected state: %d\n",
-				connection->name, ret);
+			connection->name, ret);
 		return ret;
 	}
 
@@ -343,7 +339,7 @@ static int gb_connection_hd_cport_flush(struct gb_connection *connection)
 	ret = hd->driver->cport_flush(hd, connection->hd_cport_id);
 	if (ret) {
 		dev_err(&hd->dev, "%s: failed to flush host cport: %d\n",
-				connection->name, ret);
+			connection->name, ret);
 		return ret;
 	}
 
@@ -373,7 +369,7 @@ static int gb_connection_hd_cport_quiesce(struct gb_connection *connection)
 					GB_CONNECTION_CPORT_QUIESCE_TIMEOUT);
 	if (ret) {
 		dev_err(&hd->dev, "%s: failed to quiesce host cport: %d\n",
-				connection->name, ret);
+			connection->name, ret);
 		return ret;
 	}
 
@@ -391,7 +387,7 @@ static int gb_connection_hd_cport_clear(struct gb_connection *connection)
 	ret = hd->driver->cport_clear(hd, connection->hd_cport_id);
 	if (ret) {
 		dev_err(&hd->dev, "%s: failed to clear host cport: %d\n",
-				connection->name, ret);
+			connection->name, ret);
 		return ret;
 	}
 
@@ -427,11 +423,11 @@ gb_connection_svc_connection_create(struct gb_connection *connection)
 	}
 
 	ret = gb_svc_connection_create(hd->svc,
-			hd->svc->ap_intf_id,
-			connection->hd_cport_id,
-			intf->interface_id,
-			connection->intf_cport_id,
-			cport_flags);
+				       hd->svc->ap_intf_id,
+				       connection->hd_cport_id,
+				       intf->interface_id,
+				       connection->intf_cport_id,
+				       cport_flags);
 	if (ret) {
 		dev_err(&connection->hd->dev,
 			"%s: failed to create svc connection: %d\n",
@@ -495,8 +491,8 @@ gb_connection_control_disconnecting(struct gb_connection *connection)
 	ret = gb_control_disconnecting_operation(control, cport_id);
 	if (ret) {
 		dev_err(&connection->hd->dev,
-				"%s: failed to send disconnecting: %d\n",
-				connection->name, ret);
+			"%s: failed to send disconnecting: %d\n",
+			connection->name, ret);
 	}
 }
 
@@ -535,16 +531,16 @@ gb_connection_control_disconnected(struct gb_connection *connection)
 }
 
 static int gb_connection_shutdown_operation(struct gb_connection *connection,
-						u8 phase)
+					    u8 phase)
 {
 	struct gb_cport_shutdown_request *req;
 	struct gb_operation *operation;
 	int ret;
 
 	operation = gb_operation_create_core(connection,
-						GB_REQUEST_TYPE_CPORT_SHUTDOWN,
-						sizeof(*req), 0, 0,
-						GFP_KERNEL);
+					     GB_REQUEST_TYPE_CPORT_SHUTDOWN,
+					     sizeof(*req), 0, 0,
+					     GFP_KERNEL);
 	if (!operation)
 		return -ENOMEM;
 
@@ -573,14 +569,14 @@ static int gb_connection_cport_shutdown(struct gb_connection *connection,
 			return 0;
 
 		ret = drv->cport_shutdown(hd, connection->hd_cport_id, phase,
-						GB_OPERATION_TIMEOUT_DEFAULT);
+					  GB_OPERATION_TIMEOUT_DEFAULT);
 	} else {
 		ret = gb_connection_shutdown_operation(connection, phase);
 	}
 
 	if (ret) {
 		dev_err(&hd->dev, "%s: failed to send cport shutdown (phase %d): %d\n",
-				connection->name, phase, ret);
+			connection->name, phase, ret);
 		return ret;
 	}
 
@@ -606,14 +602,14 @@ gb_connection_cport_shutdown_phase_2(struct gb_connection *connection)
  * DISCONNECTING.
  */
 static void gb_connection_cancel_operations(struct gb_connection *connection,
-						int errno)
+					    int errno)
 	__must_hold(&connection->lock)
 {
 	struct gb_operation *operation;
 
 	while (!list_empty(&connection->operations)) {
 		operation = list_last_entry(&connection->operations,
-						struct gb_operation, links);
+					    struct gb_operation, links);
 		gb_operation_get(operation);
 		spin_unlock_irq(&connection->lock);
 
@@ -635,7 +631,7 @@ static void gb_connection_cancel_operations(struct gb_connection *connection,
  */
 static void
 gb_connection_flush_incoming_operations(struct gb_connection *connection,
-						int errno)
+					int errno)
 	__must_hold(&connection->lock)
 {
 	struct gb_operation *operation;
@@ -644,7 +640,7 @@ gb_connection_flush_incoming_operations(struct gb_connection *connection,
 	while (!list_empty(&connection->operations)) {
 		incoming = false;
 		list_for_each_entry(operation, &connection->operations,
-								links) {
+				    links) {
 			if (gb_operation_is_incoming(operation)) {
 				gb_operation_get(operation);
 				incoming = true;
diff --git a/drivers/staging/greybus/connection.h b/drivers/staging/greybus/connection.h
index ec3f1d3ef3b9..8deeb1d5f008 100644
--- a/drivers/staging/greybus/connection.h
+++ b/drivers/staging/greybus/connection.h
@@ -1,4 +1,4 @@
-// SPDX-License-Identifier: GPL-2.0
+/* SPDX-License-Identifier: GPL-2.0 */
 /*
  * Greybus connections
  *
diff --git a/drivers/staging/greybus/control.c b/drivers/staging/greybus/control.c
index 35f945a12b11..ffa41d31896d 100644
--- a/drivers/staging/greybus/control.c
+++ b/drivers/staging/greybus/control.c
@@ -32,15 +32,15 @@ static int gb_control_get_version(struct gb_control *control)
 				sizeof(response));
 	if (ret) {
 		dev_err(&intf->dev,
-				"failed to get control-protocol version: %d\n",
-				ret);
+			"failed to get control-protocol version: %d\n",
+			ret);
 		return ret;
 	}
 
 	if (response.major > request.major) {
 		dev_err(&intf->dev,
-				"unsupported major control-protocol version (%u > %u)\n",
-				response.major, request.major);
+			"unsupported major control-protocol version (%u > %u)\n",
+			response.major, request.major);
 		return -ENOTSUPP;
 	}
 
@@ -48,13 +48,13 @@ static int gb_control_get_version(struct gb_control *control)
 	control->protocol_minor = response.minor;
 
 	dev_dbg(&intf->dev, "%s - %u.%u\n", __func__, response.major,
-			response.minor);
+		response.minor);
 
 	return 0;
 }
 
 static int gb_control_get_bundle_version(struct gb_control *control,
-						struct gb_bundle *bundle)
+					 struct gb_bundle *bundle)
 {
 	struct gb_interface *intf = control->connection->intf;
 	struct gb_control_bundle_version_request request;
@@ -69,8 +69,8 @@ static int gb_control_get_bundle_version(struct gb_control *control,
 				&response, sizeof(response));
 	if (ret) {
 		dev_err(&intf->dev,
-				"failed to get bundle %u class version: %d\n",
-				bundle->id, ret);
+			"failed to get bundle %u class version: %d\n",
+			bundle->id, ret);
 		return ret;
 	}
 
@@ -78,7 +78,7 @@ static int gb_control_get_bundle_version(struct gb_control *control,
 	bundle->class_minor = response.minor;
 
 	dev_dbg(&intf->dev, "%s - %u: %u.%u\n", __func__, bundle->id,
-			response.major, response.minor);
+		response.major, response.minor);
 
 	return 0;
 }
@@ -112,7 +112,7 @@ int gb_control_get_manifest_size_operation(struct gb_interface *intf)
 				NULL, 0, &response, sizeof(response));
 	if (ret) {
 		dev_err(&connection->intf->dev,
-				"failed to get manifest size: %d\n", ret);
+			"failed to get manifest size: %d\n", ret);
 		return ret;
 	}
 
@@ -149,16 +149,16 @@ int gb_control_disconnected_operation(struct gb_control *control, u16 cport_id)
 }
 
 int gb_control_disconnecting_operation(struct gb_control *control,
-					u16 cport_id)
+				       u16 cport_id)
 {
 	struct gb_control_disconnecting_request *request;
 	struct gb_operation *operation;
 	int ret;
 
 	operation = gb_operation_create_core(control->connection,
-					GB_CONTROL_TYPE_DISCONNECTING,
-					sizeof(*request), 0, 0,
-					GFP_KERNEL);
+					     GB_CONTROL_TYPE_DISCONNECTING,
+					     sizeof(*request), 0, 0,
+					     GFP_KERNEL);
 	if (!operation)
 		return -ENOMEM;
 
@@ -168,7 +168,7 @@ int gb_control_disconnecting_operation(struct gb_control *control,
 	ret = gb_operation_request_send_sync(operation);
 	if (ret) {
 		dev_err(&control->dev, "failed to send disconnecting: %d\n",
-				ret);
+			ret);
 	}
 
 	gb_operation_put(operation);
@@ -182,9 +182,10 @@ int gb_control_mode_switch_operation(struct gb_control *control)
 	int ret;
 
 	operation = gb_operation_create_core(control->connection,
-					GB_CONTROL_TYPE_MODE_SWITCH,
-					0, 0, GB_OPERATION_FLAG_UNIDIRECTIONAL,
-					GFP_KERNEL);
+					     GB_CONTROL_TYPE_MODE_SWITCH,
+					     0, 0,
+					     GB_OPERATION_FLAG_UNIDIRECTIONAL,
+					     GFP_KERNEL);
 	if (!operation)
 		return -ENOMEM;
 
@@ -400,7 +401,7 @@ int gb_control_interface_hibernate_abort(struct gb_control *control)
 }
 
 static ssize_t vendor_string_show(struct device *dev,
-			struct device_attribute *attr, char *buf)
+				  struct device_attribute *attr, char *buf)
 {
 	struct gb_control *control = to_gb_control(dev);
 
@@ -409,7 +410,7 @@ static ssize_t vendor_string_show(struct device *dev,
 static DEVICE_ATTR_RO(vendor_string);
 
 static ssize_t product_string_show(struct device *dev,
-			struct device_attribute *attr, char *buf)
+				   struct device_attribute *attr, char *buf)
 {
 	struct gb_control *control = to_gb_control(dev);
 
@@ -455,8 +456,8 @@ struct gb_control *gb_control_create(struct gb_interface *intf)
 	connection = gb_connection_create_control(intf);
 	if (IS_ERR(connection)) {
 		dev_err(&intf->dev,
-				"failed to create control connection: %ld\n",
-				PTR_ERR(connection));
+			"failed to create control connection: %ld\n",
+			PTR_ERR(connection));
 		kfree(control);
 		return ERR_CAST(connection);
 	}
@@ -485,8 +486,8 @@ int gb_control_enable(struct gb_control *control)
 	ret = gb_connection_enable_tx(control->connection);
 	if (ret) {
 		dev_err(&control->connection->intf->dev,
-				"failed to enable control connection: %d\n",
-				ret);
+			"failed to enable control connection: %d\n",
+			ret);
 		return ret;
 	}
 
@@ -547,8 +548,8 @@ int gb_control_add(struct gb_control *control)
 	ret = device_add(&control->dev);
 	if (ret) {
 		dev_err(&control->dev,
-				"failed to register control device: %d\n",
-				ret);
+			"failed to register control device: %d\n",
+			ret);
 		return ret;
 	}
 
diff --git a/drivers/staging/greybus/control.h b/drivers/staging/greybus/control.h
index 643ddb9e0f92..3a29ec05f631 100644
--- a/drivers/staging/greybus/control.h
+++ b/drivers/staging/greybus/control.h
@@ -1,4 +1,4 @@
-// SPDX-License-Identifier: GPL-2.0
+/* SPDX-License-Identifier: GPL-2.0 */
 /*
  * Greybus CPort control protocol
  *
@@ -40,7 +40,7 @@ int gb_control_get_bundle_versions(struct gb_control *control);
 int gb_control_connected_operation(struct gb_control *control, u16 cport_id);
 int gb_control_disconnected_operation(struct gb_control *control, u16 cport_id);
 int gb_control_disconnecting_operation(struct gb_control *control,
-					u16 cport_id);
+				       u16 cport_id);
 int gb_control_mode_switch_operation(struct gb_control *control);
 void gb_control_mode_switch_prepare(struct gb_control *control);
 void gb_control_mode_switch_complete(struct gb_control *control);
diff --git a/drivers/staging/greybus/core.c b/drivers/staging/greybus/core.c
index dafa430d176e..412337daf45c 100644
--- a/drivers/staging/greybus/core.c
+++ b/drivers/staging/greybus/core.c
@@ -28,7 +28,7 @@ int greybus_disabled(void)
 EXPORT_SYMBOL_GPL(greybus_disabled);
 
 static bool greybus_match_one_id(struct gb_bundle *bundle,
-				     const struct greybus_bundle_id *id)
+				 const struct greybus_bundle_id *id)
 {
 	if ((id->match_flags & GREYBUS_ID_MATCH_VENDOR) &&
 	    (id->vendor != bundle->intf->vendor_id))
@@ -48,7 +48,7 @@ static bool greybus_match_one_id(struct gb_bundle *bundle,
 static const struct greybus_bundle_id *
 greybus_match_id(struct gb_bundle *bundle, const struct greybus_bundle_id *id)
 {
-	if (id == NULL)
+	if (!id)
 		return NULL;
 
 	for (; id->vendor || id->product || id->class || id->driver_info;
diff --git a/drivers/staging/greybus/es2.c b/drivers/staging/greybus/es2.c
index b082d81833a0..be6af18cec31 100644
--- a/drivers/staging/greybus/es2.c
+++ b/drivers/staging/greybus/es2.c
@@ -216,7 +216,7 @@ static int output_async(struct es2_ap_dev *es2, void *req, u16 size, u8 cmd)
 }
 
 static int output(struct gb_host_device *hd, void *req, u16 size, u8 cmd,
-		     bool async)
+		  bool async)
 {
 	struct es2_ap_dev *es2 = hd_to_es2(hd);
 
@@ -227,7 +227,7 @@ static int output(struct gb_host_device *hd, void *req, u16 size, u8 cmd,
 }
 
 static int es2_cport_in_enable(struct es2_ap_dev *es2,
-				struct es2_cport_in *cport_in)
+			       struct es2_cport_in *cport_in)
 {
 	struct urb *urb;
 	int ret;
@@ -239,7 +239,7 @@ static int es2_cport_in_enable(struct es2_ap_dev *es2,
 		ret = usb_submit_urb(urb, GFP_KERNEL);
 		if (ret) {
 			dev_err(&es2->usb_dev->dev,
-					"failed to submit in-urb: %d\n", ret);
+				"failed to submit in-urb: %d\n", ret);
 			goto err_kill_urbs;
 		}
 	}
@@ -256,7 +256,7 @@ static int es2_cport_in_enable(struct es2_ap_dev *es2,
 }
 
 static void es2_cport_in_disable(struct es2_ap_dev *es2,
-				struct es2_cport_in *cport_in)
+				 struct es2_cport_in *cport_in)
 {
 	struct urb *urb;
 	int i;
@@ -316,8 +316,8 @@ static struct urb *next_free_urb(struct es2_ap_dev *es2, gfp_t gfp_mask)
 
 	/* Look in our pool of allocated urbs first, as that's the "fastest" */
 	for (i = 0; i < NUM_CPORT_OUT_URB; ++i) {
-		if (es2->cport_out_urb_busy[i] == false &&
-				es2->cport_out_urb_cancelled[i] == false) {
+		if (!es2->cport_out_urb_busy[i] &&
+		    !es2->cport_out_urb_cancelled[i]) {
 			es2->cport_out_urb_busy[i] = true;
 			urb = es2->cport_out_urb[i];
 			break;
@@ -487,7 +487,7 @@ static void message_cancel(struct gb_message *message)
 }
 
 static int es2_cport_allocate(struct gb_host_device *hd, int cport_id,
-				unsigned long flags)
+			      unsigned long flags)
 {
 	struct es2_ap_dev *es2 = hd_to_es2(hd);
 	struct ida *id_map = &hd->cport_id_map;
@@ -501,7 +501,7 @@ static int es2_cport_allocate(struct gb_host_device *hd, int cport_id,
 	}
 
 	if (flags & GB_CONNECTION_FLAG_OFFLOADED &&
-			flags & GB_CONNECTION_FLAG_CDSI1) {
+	    flags & GB_CONNECTION_FLAG_CDSI1) {
 		if (es2->cdsi1_in_use) {
 			dev_err(&hd->dev, "CDSI1 already in use\n");
 			return -EBUSY;
@@ -561,16 +561,16 @@ static int cport_enable(struct gb_host_device *hd, u16 cport_id,
 	req->flags = cpu_to_le32(connection_flags);
 
 	dev_dbg(&hd->dev, "%s - cport = %u, flags = %02x\n", __func__,
-			cport_id, connection_flags);
+		cport_id, connection_flags);
 
 	ret = usb_control_msg(udev, usb_sndctrlpipe(udev, 0),
-				GB_APB_REQUEST_CPORT_FLAGS,
-				USB_DIR_OUT | USB_TYPE_VENDOR |
-				USB_RECIP_INTERFACE, cport_id, 0,
-				req, sizeof(*req), ES2_USB_CTRL_TIMEOUT);
+			      GB_APB_REQUEST_CPORT_FLAGS,
+			      USB_DIR_OUT | USB_TYPE_VENDOR |
+			      USB_RECIP_INTERFACE, cport_id, 0,
+			      req, sizeof(*req), ES2_USB_CTRL_TIMEOUT);
 	if (ret != sizeof(*req)) {
 		dev_err(&udev->dev, "failed to set cport flags for port %d\n",
-				cport_id);
+			cport_id);
 		if (ret >= 0)
 			ret = -EIO;
 
@@ -596,7 +596,7 @@ static int es2_cport_connected(struct gb_host_device *hd, u16 cport_id)
 			NULL, ES2_ARPC_CPORT_TIMEOUT);
 	if (ret) {
 		dev_err(dev, "failed to set connected state for cport %u: %d\n",
-				cport_id, ret);
+			cport_id, ret);
 		return ret;
 	}
 
@@ -622,7 +622,7 @@ static int es2_cport_flush(struct gb_host_device *hd, u16 cport_id)
 }
 
 static int es2_cport_shutdown(struct gb_host_device *hd, u16 cport_id,
-				u8 phase, unsigned int timeout)
+			      u8 phase, unsigned int timeout)
 {
 	struct es2_ap_dev *es2 = hd_to_es2(hd);
 	struct device *dev = &es2->usb_dev->dev;
@@ -640,7 +640,7 @@ static int es2_cport_shutdown(struct gb_host_device *hd, u16 cport_id,
 			&result, ES2_ARPC_CPORT_TIMEOUT + timeout);
 	if (ret) {
 		dev_err(dev, "failed to send shutdown over cport %u: %d (%d)\n",
-				cport_id, ret, result);
+			cport_id, ret, result);
 		return ret;
 	}
 
@@ -648,7 +648,7 @@ static int es2_cport_shutdown(struct gb_host_device *hd, u16 cport_id,
 }
 
 static int es2_cport_quiesce(struct gb_host_device *hd, u16 cport_id,
-				size_t peer_space, unsigned int timeout)
+			     size_t peer_space, unsigned int timeout)
 {
 	struct es2_ap_dev *es2 = hd_to_es2(hd);
 	struct device *dev = &es2->usb_dev->dev;
@@ -669,7 +669,7 @@ static int es2_cport_quiesce(struct gb_host_device *hd, u16 cport_id,
 			&result, ES2_ARPC_CPORT_TIMEOUT + timeout);
 	if (ret) {
 		dev_err(dev, "failed to quiesce cport %u: %d (%d)\n",
-				cport_id, ret, result);
+			cport_id, ret, result);
 		return ret;
 	}
 
@@ -846,7 +846,7 @@ static void cport_in_callback(struct urb *urb)
 
 	if (cport_id_valid(hd, cport_id)) {
 		greybus_data_rcvd(hd, cport_id, urb->transfer_buffer,
-							urb->actual_length);
+				  urb->actual_length);
 	} else {
 		dev_err(dev, "invalid cport id %u received\n", cport_id);
 	}
@@ -1083,14 +1083,14 @@ static void apb_log_get(struct es2_ap_dev *es2, char *buf)
 
 	do {
 		retval = usb_control_msg(es2->usb_dev,
-					usb_rcvctrlpipe(es2->usb_dev, 0),
-					GB_APB_REQUEST_LOG,
-					USB_DIR_IN | USB_TYPE_VENDOR |
-					USB_RECIP_INTERFACE,
-					0x00, 0x00,
-					buf,
-					APB1_LOG_MSG_SIZE,
-					ES2_USB_CTRL_TIMEOUT);
+					 usb_rcvctrlpipe(es2->usb_dev, 0),
+					 GB_APB_REQUEST_LOG,
+					 USB_DIR_IN | USB_TYPE_VENDOR |
+					 USB_RECIP_INTERFACE,
+					 0x00, 0x00,
+					 buf,
+					 APB1_LOG_MSG_SIZE,
+					 ES2_USB_CTRL_TIMEOUT);
 		if (retval > 0)
 			kfifo_in(&es2->apb_log_fifo, buf, retval);
 	} while (retval > 0);
@@ -1116,7 +1116,7 @@ static int apb_log_poll(void *data)
 }
 
 static ssize_t apb_log_read(struct file *f, char __user *buf,
-				size_t count, loff_t *ppos)
+			    size_t count, loff_t *ppos)
 {
 	struct es2_ap_dev *es2 = file_inode(f)->i_private;
 	ssize_t ret;
@@ -1153,8 +1153,8 @@ static void usb_log_enable(struct es2_ap_dev *es2)
 		return;
 	/* XXX We will need to rename this per APB */
 	es2->apb_log_dentry = debugfs_create_file("apb_log", 0444,
-						gb_debugfs_get(), es2,
-						&apb_log_fops);
+						  gb_debugfs_get(), es2,
+						  &apb_log_fops);
 }
 
 static void usb_log_disable(struct es2_ap_dev *es2)
@@ -1170,7 +1170,7 @@ static void usb_log_disable(struct es2_ap_dev *es2)
 }
 
 static ssize_t apb_log_enable_read(struct file *f, char __user *buf,
-				size_t count, loff_t *ppos)
+				   size_t count, loff_t *ppos)
 {
 	struct es2_ap_dev *es2 = file_inode(f)->i_private;
 	int enable = !IS_ERR_OR_NULL(es2->apb_log_task);
@@ -1181,7 +1181,7 @@ static ssize_t apb_log_enable_read(struct file *f, char __user *buf,
 }
 
 static ssize_t apb_log_enable_write(struct file *f, const char __user *buf,
-				size_t count, loff_t *ppos)
+				    size_t count, loff_t *ppos)
 {
 	int enable;
 	ssize_t retval;
@@ -1274,7 +1274,7 @@ static int ap_probe(struct usb_interface *interface,
 	}
 
 	hd = gb_hd_create(&es2_driver, &udev->dev, ES2_GBUF_MSG_SIZE_MAX,
-				num_cports);
+			  num_cports);
 	if (IS_ERR(hd)) {
 		usb_put_dev(udev);
 		return PTR_ERR(hd);
@@ -1409,9 +1409,9 @@ static int ap_probe(struct usb_interface *interface,
 
 	/* XXX We will need to rename this per APB */
 	es2->apb_log_enable_dentry = debugfs_create_file("apb_log_enable",
-							0644,
-							gb_debugfs_get(), es2,
-							&apb_log_enable_fops);
+							 0644,
+							 gb_debugfs_get(), es2,
+							 &apb_log_enable_fops);
 
 	INIT_LIST_HEAD(&es2->arpcs);
 	spin_lock_init(&es2->arpc_lock);
diff --git a/drivers/staging/greybus/gpio.c b/drivers/staging/greybus/gpio.c
index b1d4698019a1..e110681e6f86 100644
--- a/drivers/staging/greybus/gpio.c
+++ b/drivers/staging/greybus/gpio.c
@@ -74,7 +74,7 @@ static int gb_gpio_activate_operation(struct gb_gpio_controller *ggc, u8 which)
 
 	request.which = which;
 	ret = gb_operation_sync(ggc->connection, GB_GPIO_TYPE_ACTIVATE,
-				 &request, sizeof(request), NULL, 0);
+				&request, sizeof(request), NULL, 0);
 	if (ret) {
 		gbphy_runtime_put_autosuspend(gbphy_dev);
 		return ret;
@@ -86,7 +86,7 @@ static int gb_gpio_activate_operation(struct gb_gpio_controller *ggc, u8 which)
 }
 
 static void gb_gpio_deactivate_operation(struct gb_gpio_controller *ggc,
-					u8 which)
+					 u8 which)
 {
 	struct gbphy_device *gbphy_dev = ggc->gbphy_dev;
 	struct device *dev = &gbphy_dev->dev;
@@ -95,7 +95,7 @@ static void gb_gpio_deactivate_operation(struct gb_gpio_controller *ggc,
 
 	request.which = which;
 	ret = gb_operation_sync(ggc->connection, GB_GPIO_TYPE_DEACTIVATE,
-				 &request, sizeof(request), NULL, 0);
+				&request, sizeof(request), NULL, 0);
 	if (ret) {
 		dev_err(dev, "failed to deactivate gpio %u\n", which);
 		goto out_pm_put;
@@ -108,7 +108,7 @@ static void gb_gpio_deactivate_operation(struct gb_gpio_controller *ggc,
 }
 
 static int gb_gpio_get_direction_operation(struct gb_gpio_controller *ggc,
-					u8 which)
+					   u8 which)
 {
 	struct device *dev = &ggc->gbphy_dev->dev;
 	struct gb_gpio_get_direction_request request;
@@ -133,7 +133,7 @@ static int gb_gpio_get_direction_operation(struct gb_gpio_controller *ggc,
 }
 
 static int gb_gpio_direction_in_operation(struct gb_gpio_controller *ggc,
-					u8 which)
+					  u8 which)
 {
 	struct gb_gpio_direction_in_request request;
 	int ret;
@@ -147,7 +147,7 @@ static int gb_gpio_direction_in_operation(struct gb_gpio_controller *ggc,
 }
 
 static int gb_gpio_direction_out_operation(struct gb_gpio_controller *ggc,
-					u8 which, bool value_high)
+					   u8 which, bool value_high)
 {
 	struct gb_gpio_direction_out_request request;
 	int ret;
@@ -162,7 +162,7 @@ static int gb_gpio_direction_out_operation(struct gb_gpio_controller *ggc,
 }
 
 static int gb_gpio_get_value_operation(struct gb_gpio_controller *ggc,
-					u8 which)
+				       u8 which)
 {
 	struct device *dev = &ggc->gbphy_dev->dev;
 	struct gb_gpio_get_value_request request;
@@ -214,7 +214,7 @@ static void gb_gpio_set_value_operation(struct gb_gpio_controller *ggc,
 }
 
 static int gb_gpio_set_debounce_operation(struct gb_gpio_controller *ggc,
-					u8 which, u16 debounce_usec)
+					  u8 which, u16 debounce_usec)
 {
 	struct gb_gpio_set_debounce_request request;
 	int ret;
@@ -257,7 +257,7 @@ static void _gb_gpio_irq_unmask(struct gb_gpio_controller *ggc, u8 hwirq)
 }
 
 static void _gb_gpio_irq_set_type(struct gb_gpio_controller *ggc,
-					u8 hwirq, u8 type)
+				  u8 hwirq, u8 type)
 {
 	struct device *dev = &ggc->gbphy_dev->dev;
 	struct gb_gpio_irq_type_request request;
@@ -589,10 +589,10 @@ static void gb_gpio_irqchip_remove(struct gb_gpio_controller *ggc)
  * before calling this function.
  */
 static int gb_gpio_irqchip_add(struct gpio_chip *chip,
-			 struct irq_chip *irqchip,
-			 unsigned int first_irq,
-			 irq_flow_handler_t handler,
-			 unsigned int type)
+			       struct irq_chip *irqchip,
+			       unsigned int first_irq,
+			       irq_flow_handler_t handler,
+			       unsigned int type)
 {
 	struct gb_gpio_controller *ggc;
 	unsigned int offset;
@@ -607,8 +607,8 @@ static int gb_gpio_irqchip_add(struct gpio_chip *chip,
 	ggc->irq_handler = handler;
 	ggc->irq_default_type = type;
 	ggc->irqdomain = irq_domain_add_simple(NULL,
-					ggc->line_max + 1, first_irq,
-					&gb_gpio_domain_ops, chip);
+					       ggc->line_max + 1, first_irq,
+					       &gb_gpio_domain_ops, chip);
 	if (!ggc->irqdomain) {
 		ggc->irqchip = NULL;
 		return -EINVAL;
@@ -648,9 +648,10 @@ static int gb_gpio_probe(struct gbphy_device *gbphy_dev,
 	if (!ggc)
 		return -ENOMEM;
 
-	connection = gb_connection_create(gbphy_dev->bundle,
-					  le16_to_cpu(gbphy_dev->cport_desc->id),
-					  gb_gpio_request_handler);
+	connection =
+		gb_connection_create(gbphy_dev->bundle,
+				     le16_to_cpu(gbphy_dev->cport_desc->id),
+				     gb_gpio_request_handler);
 	if (IS_ERR(connection)) {
 		ret = PTR_ERR(connection);
 		goto exit_ggc_free;
@@ -703,7 +704,7 @@ static int gb_gpio_probe(struct gbphy_device *gbphy_dev,
 		goto exit_line_free;
 
 	ret = gb_gpio_irqchip_add(gpio, irqc, 0,
-				   handle_level_irq, IRQ_TYPE_NONE);
+				  handle_level_irq, IRQ_TYPE_NONE);
 	if (ret) {
 		dev_err(&gbphy_dev->dev, "failed to add irq chip: %d\n", ret);
 		goto exit_line_free;
diff --git a/drivers/staging/greybus/greybus_protocols.h b/drivers/staging/greybus/greybus_protocols.h
index 9bd7b6dfb476..ddc73f10eb22 100644
--- a/drivers/staging/greybus/greybus_protocols.h
+++ b/drivers/staging/greybus/greybus_protocols.h
@@ -878,10 +878,10 @@ struct gb_pwm_disable_request {
 /* Should match up with modes in linux/spi/spi.h */
 #define GB_SPI_MODE_CPHA		0x01		/* clock phase */
 #define GB_SPI_MODE_CPOL		0x02		/* clock polarity */
-#define GB_SPI_MODE_MODE_0		(0|0)		/* (original MicroWire) */
-#define GB_SPI_MODE_MODE_1		(0|GB_SPI_MODE_CPHA)
-#define GB_SPI_MODE_MODE_2		(GB_SPI_MODE_CPOL|0)
-#define GB_SPI_MODE_MODE_3		(GB_SPI_MODE_CPOL|GB_SPI_MODE_CPHA)
+#define GB_SPI_MODE_MODE_0		(0 | 0)		/* (original MicroWire) */
+#define GB_SPI_MODE_MODE_1		(0 | GB_SPI_MODE_CPHA)
+#define GB_SPI_MODE_MODE_2		(GB_SPI_MODE_CPOL | 0)
+#define GB_SPI_MODE_MODE_3		(GB_SPI_MODE_CPOL | GB_SPI_MODE_CPHA)
 #define GB_SPI_MODE_CS_HIGH		0x04		/* chipselect active high? */
 #define GB_SPI_MODE_LSB_FIRST		0x08		/* per-word bits-on-wire */
 #define GB_SPI_MODE_3WIRE		0x10		/* SI/SO signals shared */
diff --git a/drivers/staging/greybus/hid.c b/drivers/staging/greybus/hid.c
index 04053ff075a6..0b72e1b9d325 100644
--- a/drivers/staging/greybus/hid.c
+++ b/drivers/staging/greybus/hid.c
@@ -49,8 +49,8 @@ static int gb_hid_get_report_desc(struct gb_hid *ghid, char *rdesc)
 		return ret;
 
 	ret = gb_operation_sync(ghid->connection, GB_HID_TYPE_GET_REPORT_DESC,
-				 NULL, 0, rdesc,
-				 le16_to_cpu(ghid->hdesc.wReportDescLength));
+				NULL, 0, rdesc,
+				le16_to_cpu(ghid->hdesc.wReportDescLength));
 
 	gb_pm_runtime_put_autosuspend(ghid->bundle);
 
@@ -86,7 +86,7 @@ static int gb_hid_get_report(struct gb_hid *ghid, u8 report_type, u8 report_id,
 	request.report_id = report_id;
 
 	ret = gb_operation_sync(ghid->connection, GB_HID_TYPE_GET_REPORT,
-				 &request, sizeof(request), buf, len);
+				&request, sizeof(request), buf, len);
 
 	gb_pm_runtime_put_autosuspend(ghid->bundle);
 
@@ -211,11 +211,13 @@ static void gb_hid_init_reports(struct gb_hid *ghid)
 	struct hid_report *report;
 
 	list_for_each_entry(report,
-		&hid->report_enum[HID_INPUT_REPORT].report_list, list)
+			    &hid->report_enum[HID_INPUT_REPORT].report_list,
+			    list)
 		gb_hid_init_report(ghid, report);
 
 	list_for_each_entry(report,
-		&hid->report_enum[HID_FEATURE_REPORT].report_list, list)
+			    &hid->report_enum[HID_FEATURE_REPORT].report_list,
+			    list)
 		gb_hid_init_report(ghid, report);
 }
 
@@ -259,8 +261,8 @@ static int __gb_hid_output_raw_report(struct hid_device *hid, __u8 *buf,
 }
 
 static int gb_hid_raw_request(struct hid_device *hid, unsigned char reportnum,
-			       __u8 *buf, size_t len, unsigned char rtype,
-			       int reqtype)
+			      __u8 *buf, size_t len, unsigned char rtype,
+			      int reqtype)
 {
 	switch (reqtype) {
 	case HID_REQ_GET_REPORT:
@@ -440,7 +442,7 @@ static int gb_hid_probe(struct gb_bundle *bundle,
 		return -ENOMEM;
 
 	connection = gb_connection_create(bundle, le16_to_cpu(cport_desc->id),
-						gb_hid_request_handler);
+					  gb_hid_request_handler);
 	if (IS_ERR(connection)) {
 		ret = PTR_ERR(connection);
 		goto err_free_ghid;
diff --git a/drivers/staging/greybus/i2c.c b/drivers/staging/greybus/i2c.c
index 58a37deb6579..7bb85a75d3b1 100644
--- a/drivers/staging/greybus/i2c.c
+++ b/drivers/staging/greybus/i2c.c
@@ -107,7 +107,7 @@ gb_i2c_operation_create(struct gb_connection *connection,
 
 	/* Response consists only of incoming data */
 	operation = gb_operation_create(connection, GB_I2C_TYPE_TRANSFER,
-				request_size, data_in_size, GFP_KERNEL);
+					request_size, data_in_size, GFP_KERNEL);
 	if (!operation)
 		return NULL;
 
@@ -137,7 +137,7 @@ gb_i2c_operation_create(struct gb_connection *connection,
 }
 
 static void gb_i2c_decode_response(struct i2c_msg *msgs, u32 msg_count,
-				struct gb_i2c_transfer_response *response)
+				   struct gb_i2c_transfer_response *response)
 {
 	struct i2c_msg *msg = msgs;
 	u8 *data;
@@ -164,7 +164,7 @@ static bool gb_i2c_expected_transfer_error(int errno)
 }
 
 static int gb_i2c_transfer_operation(struct gb_i2c_device *gb_i2c_dev,
-					struct i2c_msg *msgs, u32 msg_count)
+				     struct i2c_msg *msgs, u32 msg_count)
 {
 	struct gb_connection *connection = gb_i2c_dev->connection;
 	struct device *dev = &gb_i2c_dev->gbphy_dev->dev;
@@ -199,7 +199,7 @@ static int gb_i2c_transfer_operation(struct gb_i2c_device *gb_i2c_dev,
 }
 
 static int gb_i2c_master_xfer(struct i2c_adapter *adap, struct i2c_msg *msgs,
-		int msg_count)
+			      int msg_count)
 {
 	struct gb_i2c_device *gb_i2c_dev;
 
@@ -211,8 +211,8 @@ static int gb_i2c_master_xfer(struct i2c_adapter *adap, struct i2c_msg *msgs,
 #if 0
 /* Later */
 static int gb_i2c_smbus_xfer(struct i2c_adapter *adap,
-			u16 addr, unsigned short flags, char read_write,
-			u8 command, int size, union i2c_smbus_data *data)
+			     u16 addr, unsigned short flags, char read_write,
+			     u8 command, int size, union i2c_smbus_data *data)
 {
 	struct gb_i2c_device *gb_i2c_dev;
 
@@ -249,7 +249,7 @@ static int gb_i2c_device_setup(struct gb_i2c_device *gb_i2c_dev)
 }
 
 static int gb_i2c_probe(struct gbphy_device *gbphy_dev,
-			 const struct gbphy_device_id *id)
+			const struct gbphy_device_id *id)
 {
 	struct gb_connection *connection;
 	struct gb_i2c_device *gb_i2c_dev;
@@ -260,9 +260,10 @@ static int gb_i2c_probe(struct gbphy_device *gbphy_dev,
 	if (!gb_i2c_dev)
 		return -ENOMEM;
 
-	connection = gb_connection_create(gbphy_dev->bundle,
-					  le16_to_cpu(gbphy_dev->cport_desc->id),
-					  NULL);
+	connection =
+		gb_connection_create(gbphy_dev->bundle,
+				     le16_to_cpu(gbphy_dev->cport_desc->id),
+				     NULL);
 	if (IS_ERR(connection)) {
 		ret = PTR_ERR(connection);
 		goto exit_i2cdev_free;
diff --git a/drivers/staging/greybus/loopback.c b/drivers/staging/greybus/loopback.c
index 42f6f3de967c..48d85ebe404a 100644
--- a/drivers/staging/greybus/loopback.c
+++ b/drivers/staging/greybus/loopback.c
@@ -47,8 +47,6 @@ struct gb_loopback_device {
 
 	/* We need to take a lock in atomic context */
 	spinlock_t lock;
-	struct list_head list;
-	struct list_head list_op_async;
 	wait_queue_head_t wq;
 };
 
@@ -68,7 +66,6 @@ struct gb_loopback {
 	struct kfifo kfifo_lat;
 	struct mutex mutex;
 	struct task_struct *task;
-	struct list_head entry;
 	struct device *dev;
 	wait_queue_head_t wq;
 	wait_queue_head_t wq_completion;
@@ -97,7 +94,6 @@ struct gb_loopback {
 	u32 timeout_min;
 	u32 timeout_max;
 	u32 outstanding_operations_max;
-	u32 lbid;
 	u64 elapsed_nsecs;
 	u32 apbridge_latency_ts;
 	u32 gbphy_latency_ts;
@@ -145,7 +141,7 @@ static ssize_t name##_##field##_show(struct device *dev,	\
 	/* Report 0 for min and max if no transfer successed */		\
 	if (!gb->requests_completed)					\
 		return sprintf(buf, "0\n");				\
-	return sprintf(buf, "%"#type"\n", gb->name.field);	\
+	return sprintf(buf, "%" #type "\n", gb->name.field);		\
 }									\
 static DEVICE_ATTR_RO(name##_##field)
 
@@ -180,7 +176,7 @@ static ssize_t field##_show(struct device *dev,				\
 			    char *buf)					\
 {									\
 	struct gb_loopback *gb = dev_get_drvdata(dev);			\
-	return sprintf(buf, "%"#type"\n", gb->field);			\
+	return sprintf(buf, "%" #type "\n", gb->field);			\
 }									\
 static ssize_t field##_store(struct device *dev,			\
 			    struct device_attribute *attr,		\
@@ -216,7 +212,7 @@ static ssize_t field##_show(struct device *dev,				\
 			    char *buf)					\
 {									\
 	struct gb_loopback *gb = dev_get_drvdata(dev);			\
-	return sprintf(buf, "%"#type"\n", gb->field);			\
+	return sprintf(buf, "%" #type "\n", gb->field);			\
 }									\
 static ssize_t field##_store(struct device *dev,			\
 			    struct device_attribute *attr,		\
@@ -974,57 +970,7 @@ static int gb_loopback_dbgfs_latency_show(struct seq_file *s, void *unused)
 	return gb_loopback_dbgfs_latency_show_common(s, &gb->kfifo_lat,
 						     &gb->mutex);
 }
-
-static int gb_loopback_latency_open(struct inode *inode, struct file *file)
-{
-	return single_open(file, gb_loopback_dbgfs_latency_show,
-			   inode->i_private);
-}
-
-static const struct file_operations gb_loopback_debugfs_latency_ops = {
-	.open		= gb_loopback_latency_open,
-	.read		= seq_read,
-	.llseek		= seq_lseek,
-	.release	= single_release,
-};
-
-static int gb_loopback_bus_id_compare(void *priv, struct list_head *lha,
-				      struct list_head *lhb)
-{
-	struct gb_loopback *a = list_entry(lha, struct gb_loopback, entry);
-	struct gb_loopback *b = list_entry(lhb, struct gb_loopback, entry);
-	struct gb_connection *ca = a->connection;
-	struct gb_connection *cb = b->connection;
-
-	if (ca->bundle->intf->interface_id < cb->bundle->intf->interface_id)
-		return -1;
-	if (cb->bundle->intf->interface_id < ca->bundle->intf->interface_id)
-		return 1;
-	if (ca->bundle->id < cb->bundle->id)
-		return -1;
-	if (cb->bundle->id < ca->bundle->id)
-		return 1;
-	if (ca->intf_cport_id < cb->intf_cport_id)
-		return -1;
-	else if (cb->intf_cport_id < ca->intf_cport_id)
-		return 1;
-
-	return 0;
-}
-
-static void gb_loopback_insert_id(struct gb_loopback *gb)
-{
-	struct gb_loopback *gb_list;
-	u32 new_lbid = 0;
-
-	/* perform an insertion sort */
-	list_add_tail(&gb->entry, &gb_dev.list);
-	list_sort(NULL, &gb_dev.list, gb_loopback_bus_id_compare);
-	list_for_each_entry(gb_list, &gb_dev.list, entry) {
-		gb_list->lbid = 1 << new_lbid;
-		new_lbid++;
-	}
-}
+DEFINE_SHOW_ATTRIBUTE(gb_loopback_dbgfs_latency);
 
 #define DEBUGFS_NAMELEN 32
 
@@ -1084,7 +1030,7 @@ static int gb_loopback_probe(struct gb_bundle *bundle,
 	snprintf(name, sizeof(name), "raw_latency_%s",
 		 dev_name(&connection->bundle->dev));
 	gb->file = debugfs_create_file(name, S_IFREG | 0444, gb_dev.root, gb,
-				       &gb_loopback_debugfs_latency_ops);
+				       &gb_loopback_dbgfs_latency_fops);
 
 	gb->id = ida_simple_get(&loopback_ida, 0, 0, GFP_KERNEL);
 	if (gb->id < 0) {
@@ -1121,7 +1067,6 @@ static int gb_loopback_probe(struct gb_bundle *bundle,
 	}
 
 	spin_lock_irqsave(&gb_dev.lock, flags);
-	gb_loopback_insert_id(gb);
 	gb_dev.count++;
 	spin_unlock_irqrestore(&gb_dev.lock, flags);
 
@@ -1177,7 +1122,6 @@ static void gb_loopback_disconnect(struct gb_bundle *bundle)
 
 	spin_lock_irqsave(&gb_dev.lock, flags);
 	gb_dev.count--;
-	list_del(&gb->entry);
 	spin_unlock_irqrestore(&gb_dev.lock, flags);
 
 	device_unregister(gb->dev);
@@ -1204,8 +1148,6 @@ static int loopback_init(void)
 {
 	int retval;
 
-	INIT_LIST_HEAD(&gb_dev.list);
-	INIT_LIST_HEAD(&gb_dev.list_op_async);
 	spin_lock_init(&gb_dev.lock);
 	gb_dev.root = debugfs_create_dir("gb_loopback", NULL);
 
diff --git a/drivers/staging/greybus/module.c b/drivers/staging/greybus/module.c
index 894d02e8d8b7..b251a53d0e8e 100644
--- a/drivers/staging/greybus/module.c
+++ b/drivers/staging/greybus/module.c
@@ -9,10 +9,9 @@
 #include "greybus.h"
 #include "greybus_trace.h"
 
-
 static ssize_t eject_store(struct device *dev,
-				struct device_attribute *attr,
-				const char *buf, size_t len)
+			   struct device_attribute *attr,
+			   const char *buf, size_t len)
 {
 	struct gb_module *module = to_gb_module(dev);
 	struct gb_interface *intf;
@@ -48,7 +47,7 @@ static ssize_t eject_store(struct device *dev,
 static DEVICE_ATTR_WO(eject);
 
 static ssize_t module_id_show(struct device *dev,
-				struct device_attribute *attr, char *buf)
+			      struct device_attribute *attr, char *buf)
 {
 	struct gb_module *module = to_gb_module(dev);
 
@@ -57,7 +56,7 @@ static ssize_t module_id_show(struct device *dev,
 static DEVICE_ATTR_RO(module_id);
 
 static ssize_t num_interfaces_show(struct device *dev,
-				struct device_attribute *attr, char *buf)
+				   struct device_attribute *attr, char *buf)
 {
 	struct gb_module *module = to_gb_module(dev);
 
@@ -88,7 +87,7 @@ struct device_type greybus_module_type = {
 };
 
 struct gb_module *gb_module_create(struct gb_host_device *hd, u8 module_id,
-					size_t num_interfaces)
+				   size_t num_interfaces)
 {
 	struct gb_interface *intf;
 	struct gb_module *module;
@@ -117,7 +116,7 @@ struct gb_module *gb_module_create(struct gb_host_device *hd, u8 module_id,
 		intf = gb_interface_create(module, module_id + i);
 		if (!intf) {
 			dev_err(&module->dev, "failed to create interface %u\n",
-					module_id + i);
+				module_id + i);
 			goto err_put_interfaces;
 		}
 		module->interfaces[i] = intf;
@@ -149,8 +148,8 @@ static void gb_module_register_interface(struct gb_interface *intf)
 	if (ret) {
 		if (intf->type != GB_INTERFACE_TYPE_DUMMY) {
 			dev_err(&module->dev,
-					"failed to activate interface %u: %d\n",
-					intf_id, ret);
+				"failed to activate interface %u: %d\n",
+				intf_id, ret);
 		}
 
 		gb_interface_add(intf);
@@ -164,7 +163,7 @@ static void gb_module_register_interface(struct gb_interface *intf)
 	ret = gb_interface_enable(intf);
 	if (ret) {
 		dev_err(&module->dev, "failed to enable interface %u: %d\n",
-				intf_id, ret);
+			intf_id, ret);
 		goto err_interface_deactivate;
 	}
 
diff --git a/drivers/staging/greybus/operation.c b/drivers/staging/greybus/operation.c
index c462b1c046cd..fe268f7b63ed 100644
--- a/drivers/staging/greybus/operation.c
+++ b/drivers/staging/greybus/operation.c
@@ -31,7 +31,7 @@ static DECLARE_WAIT_QUEUE_HEAD(gb_operation_cancellation_queue);
 static DEFINE_SPINLOCK(gb_operations_lock);
 
 static int gb_operation_response_send(struct gb_operation *operation,
-					int errno);
+				      int errno);
 
 /*
  * Increment operation active count and add to connection list unless the
@@ -202,7 +202,7 @@ gb_operation_find_outgoing(struct gb_connection *connection, u16 operation_id)
 	spin_lock_irqsave(&connection->lock, flags);
 	list_for_each_entry(operation, &connection->operations, links)
 		if (operation->id == operation_id &&
-				!gb_operation_is_incoming(operation)) {
+		    !gb_operation_is_incoming(operation)) {
 			gb_operation_get(operation);
 			found = true;
 			break;
@@ -307,8 +307,9 @@ static void gb_operation_timeout(struct timer_list *t)
 }
 
 static void gb_operation_message_init(struct gb_host_device *hd,
-				struct gb_message *message, u16 operation_id,
-				size_t payload_size, u8 type)
+				      struct gb_message *message,
+				      u16 operation_id,
+				      size_t payload_size, u8 type)
 {
 	struct gb_operation_msg_hdr *header;
 
@@ -358,7 +359,7 @@ static void gb_operation_message_init(struct gb_host_device *hd,
  */
 static struct gb_message *
 gb_operation_message_alloc(struct gb_host_device *hd, u8 type,
-				size_t payload_size, gfp_t gfp_flags)
+			   size_t payload_size, gfp_t gfp_flags)
 {
 	struct gb_message *message;
 	struct gb_operation_msg_hdr *header;
@@ -366,7 +367,7 @@ gb_operation_message_alloc(struct gb_host_device *hd, u8 type,
 
 	if (message_size > hd->buffer_size_max) {
 		dev_warn(&hd->dev, "requested message size too big (%zu > %zu)\n",
-				message_size, hd->buffer_size_max);
+			 message_size, hd->buffer_size_max);
 		return NULL;
 	}
 
@@ -465,7 +466,7 @@ static u8 gb_operation_errno_map(int errno)
 }
 
 bool gb_operation_response_alloc(struct gb_operation *operation,
-					size_t response_size, gfp_t gfp)
+				 size_t response_size, gfp_t gfp)
 {
 	struct gb_host_device *hd = operation->connection->hd;
 	struct gb_operation_msg_hdr *request_header;
@@ -516,8 +517,8 @@ EXPORT_SYMBOL_GPL(gb_operation_response_alloc);
  */
 static struct gb_operation *
 gb_operation_create_common(struct gb_connection *connection, u8 type,
-				size_t request_size, size_t response_size,
-				unsigned long op_flags, gfp_t gfp_flags)
+			   size_t request_size, size_t response_size,
+			   unsigned long op_flags, gfp_t gfp_flags)
 {
 	struct gb_host_device *hd = connection->hd;
 	struct gb_operation *operation;
@@ -572,9 +573,9 @@ gb_operation_create_common(struct gb_connection *connection, u8 type,
  */
 struct gb_operation *
 gb_operation_create_flags(struct gb_connection *connection,
-				u8 type, size_t request_size,
-				size_t response_size, unsigned long flags,
-				gfp_t gfp)
+			  u8 type, size_t request_size,
+			  size_t response_size, unsigned long flags,
+			  gfp_t gfp)
 {
 	struct gb_operation *operation;
 
@@ -587,8 +588,8 @@ gb_operation_create_flags(struct gb_connection *connection,
 		flags &= GB_OPERATION_FLAG_USER_MASK;
 
 	operation = gb_operation_create_common(connection, type,
-						request_size, response_size,
-						flags, gfp);
+					       request_size, response_size,
+					       flags, gfp);
 	if (operation)
 		trace_gb_operation_create(operation);
 
@@ -598,22 +599,23 @@ EXPORT_SYMBOL_GPL(gb_operation_create_flags);
 
 struct gb_operation *
 gb_operation_create_core(struct gb_connection *connection,
-				u8 type, size_t request_size,
-				size_t response_size, unsigned long flags,
-				gfp_t gfp)
+			 u8 type, size_t request_size,
+			 size_t response_size, unsigned long flags,
+			 gfp_t gfp)
 {
 	struct gb_operation *operation;
 
 	flags |= GB_OPERATION_FLAG_CORE;
 
 	operation = gb_operation_create_common(connection, type,
-						request_size, response_size,
-						flags, gfp);
+					       request_size, response_size,
+					       flags, gfp);
 	if (operation)
 		trace_gb_operation_create_core(operation);
 
 	return operation;
 }
+
 /* Do not export this function. */
 
 size_t gb_operation_get_payload_size_max(struct gb_connection *connection)
@@ -626,7 +628,7 @@ EXPORT_SYMBOL_GPL(gb_operation_get_payload_size_max);
 
 static struct gb_operation *
 gb_operation_create_incoming(struct gb_connection *connection, u16 id,
-				u8 type, void *data, size_t size)
+			     u8 type, void *data, size_t size)
 {
 	struct gb_operation *operation;
 	size_t request_size;
@@ -639,9 +641,9 @@ gb_operation_create_incoming(struct gb_connection *connection, u16 id,
 		flags |= GB_OPERATION_FLAG_UNIDIRECTIONAL;
 
 	operation = gb_operation_create_common(connection, type,
-						request_size,
-						GB_REQUEST_TYPE_INVALID,
-						flags, GFP_ATOMIC);
+					       request_size,
+					       GB_REQUEST_TYPE_INVALID,
+					       flags, GFP_ATOMIC);
 	if (!operation)
 		return NULL;
 
@@ -716,9 +718,9 @@ static void gb_operation_sync_callback(struct gb_operation *operation)
  * or a negative errno.
  */
 int gb_operation_request_send(struct gb_operation *operation,
-				gb_operation_callback callback,
-				unsigned int timeout,
-				gfp_t gfp)
+			      gb_operation_callback callback,
+			      unsigned int timeout,
+			      gfp_t gfp)
 {
 	struct gb_connection *connection = operation->connection;
 	struct gb_operation_msg_hdr *header;
@@ -790,7 +792,7 @@ EXPORT_SYMBOL_GPL(gb_operation_request_send);
  * operation.
  */
 int gb_operation_request_send_sync_timeout(struct gb_operation *operation,
-						unsigned int timeout)
+					   unsigned int timeout)
 {
 	int ret;
 
@@ -819,13 +821,13 @@ EXPORT_SYMBOL_GPL(gb_operation_request_send_sync_timeout);
  * allocate the response message if necessary.
  */
 static int gb_operation_response_send(struct gb_operation *operation,
-					int errno)
+				      int errno)
 {
 	struct gb_connection *connection = operation->connection;
 	int ret;
 
 	if (!operation->response &&
-			!gb_operation_is_unidirectional(operation)) {
+	    !gb_operation_is_unidirectional(operation)) {
 		if (!gb_operation_response_alloc(operation, 0, GFP_KERNEL))
 			return -ENOMEM;
 	}
@@ -867,7 +869,7 @@ static int gb_operation_response_send(struct gb_operation *operation,
  * This function is called when a message send request has completed.
  */
 void greybus_message_sent(struct gb_host_device *hd,
-					struct gb_message *message, int status)
+			  struct gb_message *message, int status)
 {
 	struct gb_operation *operation = message->operation;
 	struct gb_connection *connection = operation->connection;
@@ -895,7 +897,7 @@ void greybus_message_sent(struct gb_host_device *hd,
 	} else if (status || gb_operation_is_unidirectional(operation)) {
 		if (gb_operation_result_set(operation, status)) {
 			queue_work(gb_operation_completion_wq,
-					&operation->work);
+				   &operation->work);
 		}
 	}
 }
@@ -921,7 +923,7 @@ static void gb_connection_recv_request(struct gb_connection *connection,
 	type = header->type;
 
 	operation = gb_operation_create_incoming(connection, operation_id,
-						type, data, size);
+						 type, data, size);
 	if (!operation) {
 		dev_err(&connection->hd->dev,
 			"%s: can't create incoming operation\n",
@@ -966,16 +968,16 @@ static void gb_connection_recv_response(struct gb_connection *connection,
 
 	if (!operation_id) {
 		dev_err_ratelimited(&connection->hd->dev,
-				"%s: invalid response id 0 received\n",
-				connection->name);
+				    "%s: invalid response id 0 received\n",
+				    connection->name);
 		return;
 	}
 
 	operation = gb_operation_find_outgoing(connection, operation_id);
 	if (!operation) {
 		dev_err_ratelimited(&connection->hd->dev,
-				"%s: unexpected response id 0x%04x received\n",
-				connection->name, operation_id);
+				    "%s: unexpected response id 0x%04x received\n",
+				    connection->name, operation_id);
 		return;
 	}
 
@@ -984,18 +986,18 @@ static void gb_connection_recv_response(struct gb_connection *connection,
 	message_size = sizeof(*header) + message->payload_size;
 	if (!errno && size > message_size) {
 		dev_err_ratelimited(&connection->hd->dev,
-				"%s: malformed response 0x%02x received (%zu > %zu)\n",
-				connection->name, header->type,
-				size, message_size);
+				    "%s: malformed response 0x%02x received (%zu > %zu)\n",
+				    connection->name, header->type,
+				    size, message_size);
 		errno = -EMSGSIZE;
 	} else if (!errno && size < message_size) {
 		if (gb_operation_short_response_allowed(operation)) {
 			message->payload_size = size - sizeof(*header);
 		} else {
 			dev_err_ratelimited(&connection->hd->dev,
-					"%s: short response 0x%02x received (%zu < %zu)\n",
-					connection->name, header->type,
-					size, message_size);
+					    "%s: short response 0x%02x received (%zu < %zu)\n",
+					    connection->name, header->type,
+					    size, message_size);
 			errno = -EMSGSIZE;
 		}
 	}
@@ -1022,22 +1024,22 @@ static void gb_connection_recv_response(struct gb_connection *connection,
  * with, it's effectively dropped).
  */
 void gb_connection_recv(struct gb_connection *connection,
-				void *data, size_t size)
+			void *data, size_t size)
 {
 	struct gb_operation_msg_hdr header;
 	struct device *dev = &connection->hd->dev;
 	size_t msg_size;
 
 	if (connection->state == GB_CONNECTION_STATE_DISABLED ||
-			gb_connection_is_offloaded(connection)) {
+	    gb_connection_is_offloaded(connection)) {
 		dev_warn_ratelimited(dev, "%s: dropping %zu received bytes\n",
-				connection->name, size);
+				     connection->name, size);
 		return;
 	}
 
 	if (size < sizeof(header)) {
 		dev_err_ratelimited(dev, "%s: short message received\n",
-				connection->name);
+				    connection->name);
 		return;
 	}
 
@@ -1046,19 +1048,19 @@ void gb_connection_recv(struct gb_connection *connection,
 	msg_size = le16_to_cpu(header.size);
 	if (size < msg_size) {
 		dev_err_ratelimited(dev,
-				"%s: incomplete message 0x%04x of type 0x%02x received (%zu < %zu)\n",
-				connection->name,
-				le16_to_cpu(header.operation_id),
-				header.type, size, msg_size);
+				    "%s: incomplete message 0x%04x of type 0x%02x received (%zu < %zu)\n",
+				    connection->name,
+				    le16_to_cpu(header.operation_id),
+				    header.type, size, msg_size);
 		return;		/* XXX Should still complete operation */
 	}
 
 	if (header.type & GB_MESSAGE_TYPE_RESPONSE) {
 		gb_connection_recv_response(connection,	&header, data,
-						msg_size);
+					    msg_size);
 	} else {
 		gb_connection_recv_request(connection, &header, data,
-						msg_size);
+					   msg_size);
 	}
 }
 
@@ -1079,7 +1081,7 @@ void gb_operation_cancel(struct gb_operation *operation, int errno)
 
 	atomic_inc(&operation->waiters);
 	wait_event(gb_operation_cancellation_queue,
-			!gb_operation_is_active(operation));
+		   !gb_operation_is_active(operation));
 	atomic_dec(&operation->waiters);
 }
 EXPORT_SYMBOL_GPL(gb_operation_cancel);
@@ -1106,7 +1108,7 @@ void gb_operation_cancel_incoming(struct gb_operation *operation, int errno)
 
 	atomic_inc(&operation->waiters);
 	wait_event(gb_operation_cancellation_queue,
-			!gb_operation_is_active(operation));
+		   !gb_operation_is_active(operation));
 	atomic_dec(&operation->waiters);
 }
 
@@ -1134,9 +1136,9 @@ void gb_operation_cancel_incoming(struct gb_operation *operation, int errno)
  * If there is an error, the response buffer is left alone.
  */
 int gb_operation_sync_timeout(struct gb_connection *connection, int type,
-				void *request, int request_size,
-				void *response, int response_size,
-				unsigned int timeout)
+			      void *request, int request_size,
+			      void *response, int response_size,
+			      unsigned int timeout)
 {
 	struct gb_operation *operation;
 	int ret;
@@ -1187,8 +1189,9 @@ EXPORT_SYMBOL_GPL(gb_operation_sync_timeout);
  * the request as actually reached the remote end of the connection.
  */
 int gb_operation_unidirectional_timeout(struct gb_connection *connection,
-				int type, void *request, int request_size,
-				unsigned int timeout)
+					int type, void *request,
+					int request_size,
+					unsigned int timeout)
 {
 	struct gb_operation *operation;
 	int ret;
@@ -1197,9 +1200,9 @@ int gb_operation_unidirectional_timeout(struct gb_connection *connection,
 		return -EINVAL;
 
 	operation = gb_operation_create_flags(connection, type,
-					request_size, 0,
-					GB_OPERATION_FLAG_UNIDIRECTIONAL,
-					GFP_KERNEL);
+					      request_size, 0,
+					      GB_OPERATION_FLAG_UNIDIRECTIONAL,
+					      GFP_KERNEL);
 	if (!operation)
 		return -ENOMEM;
 
@@ -1222,17 +1225,19 @@ EXPORT_SYMBOL_GPL(gb_operation_unidirectional_timeout);
 int __init gb_operation_init(void)
 {
 	gb_message_cache = kmem_cache_create("gb_message_cache",
-				sizeof(struct gb_message), 0, 0, NULL);
+					     sizeof(struct gb_message), 0, 0,
+					     NULL);
 	if (!gb_message_cache)
 		return -ENOMEM;
 
 	gb_operation_cache = kmem_cache_create("gb_operation_cache",
-				sizeof(struct gb_operation), 0, 0, NULL);
+					       sizeof(struct gb_operation), 0,
+					       0, NULL);
 	if (!gb_operation_cache)
 		goto err_destroy_message_cache;
 
 	gb_operation_completion_wq = alloc_workqueue("greybus_completion",
-				0, 0);
+						     0, 0);
 	if (!gb_operation_completion_wq)
 		goto err_destroy_operation_cache;
 
diff --git a/drivers/staging/greybus/svc.c b/drivers/staging/greybus/svc.c
index a2bb7e1a3db3..05bc45287b87 100644
--- a/drivers/staging/greybus/svc.c
+++ b/drivers/staging/greybus/svc.c
@@ -20,11 +20,10 @@ struct gb_svc_deferred_request {
 	struct gb_operation *operation;
 };
 
-
 static int gb_svc_queue_deferred_request(struct gb_operation *operation);
 
 static ssize_t endo_id_show(struct device *dev,
-			struct device_attribute *attr, char *buf)
+			    struct device_attribute *attr, char *buf)
 {
 	struct gb_svc *svc = to_gb_svc(dev);
 
@@ -33,7 +32,7 @@ static ssize_t endo_id_show(struct device *dev,
 static DEVICE_ATTR_RO(endo_id);
 
 static ssize_t ap_intf_id_show(struct device *dev,
-			struct device_attribute *attr, char *buf)
+			       struct device_attribute *attr, char *buf)
 {
 	struct gb_svc *svc = to_gb_svc(dev);
 
@@ -304,8 +303,8 @@ int gb_svc_intf_vsys_set(struct gb_svc *svc, u8 intf_id, bool enable)
 		type = GB_SVC_TYPE_INTF_VSYS_DISABLE;
 
 	ret = gb_operation_sync(svc->connection, type,
-			&request, sizeof(request),
-			&response, sizeof(response));
+				&request, sizeof(request),
+				&response, sizeof(response));
 	if (ret < 0)
 		return ret;
 	if (response.result_code != GB_SVC_INTF_VSYS_OK)
@@ -327,8 +326,8 @@ int gb_svc_intf_refclk_set(struct gb_svc *svc, u8 intf_id, bool enable)
 		type = GB_SVC_TYPE_INTF_REFCLK_DISABLE;
 
 	ret = gb_operation_sync(svc->connection, type,
-			&request, sizeof(request),
-			&response, sizeof(response));
+				&request, sizeof(request),
+				&response, sizeof(response));
 	if (ret < 0)
 		return ret;
 	if (response.result_code != GB_SVC_INTF_REFCLK_OK)
@@ -350,8 +349,8 @@ int gb_svc_intf_unipro_set(struct gb_svc *svc, u8 intf_id, bool enable)
 		type = GB_SVC_TYPE_INTF_UNIPRO_DISABLE;
 
 	ret = gb_operation_sync(svc->connection, type,
-			&request, sizeof(request),
-			&response, sizeof(response));
+				&request, sizeof(request),
+				&response, sizeof(response));
 	if (ret < 0)
 		return ret;
 	if (response.result_code != GB_SVC_INTF_UNIPRO_OK)
@@ -368,15 +367,15 @@ int gb_svc_intf_activate(struct gb_svc *svc, u8 intf_id, u8 *intf_type)
 	request.intf_id = intf_id;
 
 	ret = gb_operation_sync_timeout(svc->connection,
-			GB_SVC_TYPE_INTF_ACTIVATE,
-			&request, sizeof(request),
-			&response, sizeof(response),
-			SVC_INTF_ACTIVATE_TIMEOUT);
+					GB_SVC_TYPE_INTF_ACTIVATE,
+					&request, sizeof(request),
+					&response, sizeof(response),
+					SVC_INTF_ACTIVATE_TIMEOUT);
 	if (ret < 0)
 		return ret;
 	if (response.status != GB_SVC_OP_SUCCESS) {
 		dev_err(&svc->dev, "failed to activate interface %u: %u\n",
-				intf_id, response.status);
+			intf_id, response.status);
 		return -EREMOTEIO;
 	}
 
@@ -430,14 +429,14 @@ int gb_svc_dme_peer_get(struct gb_svc *svc, u8 intf_id, u16 attr, u16 selector,
 				&response, sizeof(response));
 	if (ret) {
 		dev_err(&svc->dev, "failed to get DME attribute (%u 0x%04x %u): %d\n",
-				intf_id, attr, selector, ret);
+			intf_id, attr, selector, ret);
 		return ret;
 	}
 
 	result = le16_to_cpu(response.result_code);
 	if (result) {
 		dev_err(&svc->dev, "UniPro error while getting DME attribute (%u 0x%04x %u): %u\n",
-				intf_id, attr, selector, result);
+			intf_id, attr, selector, result);
 		return -EREMOTEIO;
 	}
 
@@ -465,14 +464,14 @@ int gb_svc_dme_peer_set(struct gb_svc *svc, u8 intf_id, u16 attr, u16 selector,
 				&response, sizeof(response));
 	if (ret) {
 		dev_err(&svc->dev, "failed to set DME attribute (%u 0x%04x %u %u): %d\n",
-				intf_id, attr, selector, value, ret);
+			intf_id, attr, selector, value, ret);
 		return ret;
 	}
 
 	result = le16_to_cpu(response.result_code);
 	if (result) {
 		dev_err(&svc->dev, "UniPro error while setting DME attribute (%u 0x%04x %u %u): %u\n",
-				intf_id, attr, selector, value, result);
+			intf_id, attr, selector, value, result);
 		return -EREMOTEIO;
 	}
 
@@ -480,9 +479,9 @@ int gb_svc_dme_peer_set(struct gb_svc *svc, u8 intf_id, u16 attr, u16 selector,
 }
 
 int gb_svc_connection_create(struct gb_svc *svc,
-				u8 intf1_id, u16 cport1_id,
-				u8 intf2_id, u16 cport2_id,
-				u8 cport_flags)
+			     u8 intf1_id, u16 cport1_id,
+			     u8 intf2_id, u16 cport2_id,
+			     u8 cport_flags)
 {
 	struct gb_svc_conn_create_request request;
 
@@ -513,13 +512,13 @@ void gb_svc_connection_destroy(struct gb_svc *svc, u8 intf1_id, u16 cport1_id,
 				&request, sizeof(request), NULL, 0);
 	if (ret) {
 		dev_err(&svc->dev, "failed to destroy connection (%u:%u %u:%u): %d\n",
-				intf1_id, cport1_id, intf2_id, cport2_id, ret);
+			intf1_id, cport1_id, intf2_id, cport2_id, ret);
 	}
 }
 
 /* Creates bi-directional routes between the devices */
 int gb_svc_route_create(struct gb_svc *svc, u8 intf1_id, u8 dev1_id,
-			       u8 intf2_id, u8 dev2_id)
+			u8 intf2_id, u8 dev2_id)
 {
 	struct gb_svc_route_create_request request;
 
@@ -545,7 +544,7 @@ void gb_svc_route_destroy(struct gb_svc *svc, u8 intf1_id, u8 intf2_id)
 				&request, sizeof(request), NULL, 0);
 	if (ret) {
 		dev_err(&svc->dev, "failed to destroy route (%u %u): %d\n",
-				intf1_id, intf2_id, ret);
+			intf1_id, intf2_id, ret);
 	}
 }
 
@@ -648,8 +647,8 @@ static int gb_svc_version_request(struct gb_operation *op)
 
 	if (op->request->payload_size < sizeof(*request)) {
 		dev_err(&svc->dev, "short version request (%zu < %zu)\n",
-				op->request->payload_size,
-				sizeof(*request));
+			op->request->payload_size,
+			sizeof(*request));
 		return -EINVAL;
 	}
 
@@ -657,7 +656,7 @@ static int gb_svc_version_request(struct gb_operation *op)
 
 	if (request->major > GB_SVC_VERSION_MAJOR) {
 		dev_warn(&svc->dev, "unsupported major version (%u > %u)\n",
-				request->major, GB_SVC_VERSION_MAJOR);
+			 request->major, GB_SVC_VERSION_MAJOR);
 		return -ENOTSUPP;
 	}
 
@@ -845,8 +844,8 @@ static int gb_svc_hello(struct gb_operation *op)
 
 	if (op->request->payload_size < sizeof(*hello_request)) {
 		dev_warn(&svc->dev, "short hello request (%zu < %zu)\n",
-				op->request->payload_size,
-				sizeof(*hello_request));
+			 op->request->payload_size,
+			 sizeof(*hello_request));
 		return -EINVAL;
 	}
 
@@ -877,7 +876,7 @@ static int gb_svc_hello(struct gb_operation *op)
 }
 
 static struct gb_interface *gb_svc_interface_lookup(struct gb_svc *svc,
-							u8 intf_id)
+						    u8 intf_id)
 {
 	struct gb_host_device *hd = svc->hd;
 	struct gb_module *module;
@@ -889,7 +888,7 @@ static struct gb_interface *gb_svc_interface_lookup(struct gb_svc *svc,
 		num_interfaces = module->num_interfaces;
 
 		if (intf_id >= module_id &&
-				intf_id < module_id + num_interfaces) {
+		    intf_id < module_id + num_interfaces) {
 			return module->interfaces[intf_id - module_id];
 		}
 	}
@@ -938,8 +937,8 @@ static void gb_svc_process_hello_deferred(struct gb_operation *operation)
 
 	if (ret)
 		dev_warn(&svc->dev,
-			"power mode change failed on AP to switch link: %d\n",
-			ret);
+			 "power mode change failed on AP to switch link: %d\n",
+			 ret);
 }
 
 static void gb_svc_process_module_inserted(struct gb_operation *operation)
@@ -961,17 +960,17 @@ static void gb_svc_process_module_inserted(struct gb_operation *operation)
 	flags = le16_to_cpu(request->flags);
 
 	dev_dbg(&svc->dev, "%s - id = %u, num_interfaces = %zu, flags = 0x%04x\n",
-			__func__, module_id, num_interfaces, flags);
+		__func__, module_id, num_interfaces, flags);
 
 	if (flags & GB_SVC_MODULE_INSERTED_FLAG_NO_PRIMARY) {
 		dev_warn(&svc->dev, "no primary interface detected on module %u\n",
-				module_id);
+			 module_id);
 	}
 
 	module = gb_svc_module_lookup(svc, module_id);
 	if (module) {
 		dev_warn(&svc->dev, "unexpected module-inserted event %u\n",
-				module_id);
+			 module_id);
 		return;
 	}
 
@@ -1007,7 +1006,7 @@ static void gb_svc_process_module_removed(struct gb_operation *operation)
 	module = gb_svc_module_lookup(svc, module_id);
 	if (!module) {
 		dev_warn(&svc->dev, "unexpected module-removed event %u\n",
-				module_id);
+			 module_id);
 		return;
 	}
 
@@ -1066,7 +1065,7 @@ static void gb_svc_process_intf_mailbox_event(struct gb_operation *operation)
 	mailbox = le32_to_cpu(request->mailbox);
 
 	dev_dbg(&svc->dev, "%s - id = %u, result = 0x%04x, mailbox = 0x%08x\n",
-			__func__, intf_id, result_code, mailbox);
+		__func__, intf_id, result_code, mailbox);
 
 	intf = gb_svc_interface_lookup(svc, intf_id);
 	if (!intf) {
@@ -1140,7 +1139,7 @@ static int gb_svc_intf_reset_recv(struct gb_operation *op)
 
 	if (request->payload_size < sizeof(*reset)) {
 		dev_warn(&svc->dev, "short reset request received (%zu < %zu)\n",
-				request->payload_size, sizeof(*reset));
+			 request->payload_size, sizeof(*reset));
 		return -EINVAL;
 	}
 	reset = request->payload;
@@ -1157,14 +1156,14 @@ static int gb_svc_module_inserted_recv(struct gb_operation *op)
 
 	if (op->request->payload_size < sizeof(*request)) {
 		dev_warn(&svc->dev, "short module-inserted request received (%zu < %zu)\n",
-				op->request->payload_size, sizeof(*request));
+			 op->request->payload_size, sizeof(*request));
 		return -EINVAL;
 	}
 
 	request = op->request->payload;
 
 	dev_dbg(&svc->dev, "%s - id = %u\n", __func__,
-			request->primary_intf_id);
+		request->primary_intf_id);
 
 	return gb_svc_queue_deferred_request(op);
 }
@@ -1176,14 +1175,14 @@ static int gb_svc_module_removed_recv(struct gb_operation *op)
 
 	if (op->request->payload_size < sizeof(*request)) {
 		dev_warn(&svc->dev, "short module-removed request received (%zu < %zu)\n",
-				op->request->payload_size, sizeof(*request));
+			 op->request->payload_size, sizeof(*request));
 		return -EINVAL;
 	}
 
 	request = op->request->payload;
 
 	dev_dbg(&svc->dev, "%s - id = %u\n", __func__,
-			request->primary_intf_id);
+		request->primary_intf_id);
 
 	return gb_svc_queue_deferred_request(op);
 }
@@ -1209,7 +1208,7 @@ static int gb_svc_intf_mailbox_event_recv(struct gb_operation *op)
 
 	if (op->request->payload_size < sizeof(*request)) {
 		dev_warn(&svc->dev, "short mailbox request received (%zu < %zu)\n",
-				op->request->payload_size, sizeof(*request));
+			 op->request->payload_size, sizeof(*request));
 		return -EINVAL;
 	}
 
@@ -1254,7 +1253,7 @@ static int gb_svc_request_handler(struct gb_operation *op)
 
 	if (ret) {
 		dev_warn(&svc->dev, "unexpected request 0x%02x received (state %u)\n",
-				type, svc->state);
+			 type, svc->state);
 		return ret;
 	}
 
@@ -1329,10 +1328,10 @@ struct gb_svc *gb_svc_create(struct gb_host_device *hd)
 	svc->hd = hd;
 
 	svc->connection = gb_connection_create_static(hd, GB_SVC_CPORT_ID,
-						gb_svc_request_handler);
+						      gb_svc_request_handler);
 	if (IS_ERR(svc->connection)) {
 		dev_err(&svc->dev, "failed to create connection: %ld\n",
-				PTR_ERR(svc->connection));
+			PTR_ERR(svc->connection));
 		goto err_put_device;
 	}
 
diff --git a/drivers/staging/greybus/tools/README.loopback b/drivers/staging/greybus/tools/README.loopback
index 845b08dc4696..070a510cbe7c 100644
--- a/drivers/staging/greybus/tools/README.loopback
+++ b/drivers/staging/greybus/tools/README.loopback
@@ -79,7 +79,7 @@ Here is the summary of the available options:
    -t     must be one of the test names - sink, transfer or ping
    -i     iteration count - the number of iterations to run the test over
  Optional arguments
-   -S     sysfs location - location for greybus 'endo' entires default /sys/bus/greybus/devices/
+   -S     sysfs location - location for greybus 'endo' entries default /sys/bus/greybus/devices/
    -D     debugfs location - location for loopback debugfs entries default /sys/kernel/debug/gb_loopback/
    -s     size of data packet to send during test - defaults to zero
    -m     mask - a bit mask of connections to include example: -m 8 = 4th connection -m 9 = 1st and 4th connection etc
diff --git a/drivers/staging/greybus/tools/loopback_test.c b/drivers/staging/greybus/tools/loopback_test.c
index b82e2befe935..2fa88092514d 100644
--- a/drivers/staging/greybus/tools/loopback_test.c
+++ b/drivers/staging/greybus/tools/loopback_test.c
@@ -192,7 +192,7 @@ void usage(void)
 	"   -t     must be one of the test names - sink, transfer or ping\n"
 	"   -i     iteration count - the number of iterations to run the test over\n"
 	" Optional arguments\n"
-	"   -S     sysfs location - location for greybus 'endo' entires default /sys/bus/greybus/devices/\n"
+	"   -S     sysfs location - location for greybus 'endo' entries default /sys/bus/greybus/devices/\n"
 	"   -D     debugfs location - location for loopback debugfs entries default /sys/kernel/debug/gb_loopback/\n"
 	"   -s     size of data packet to send during test - defaults to zero\n"
 	"   -m     mask - a bit mask of connections to include example: -m 8 = 4th connection -m 9 = 1st and 4th connection etc\n"
diff --git a/drivers/staging/greybus/uart.c b/drivers/staging/greybus/uart.c
index 8a006323c3c1..b3bffe91ae99 100644
--- a/drivers/staging/greybus/uart.c
+++ b/drivers/staging/greybus/uart.c
@@ -616,40 +616,33 @@ static void gb_tty_unthrottle(struct tty_struct *tty)
 	}
 }
 
-static int get_serial_info(struct gb_tty *gb_tty,
-			   struct serial_struct __user *info)
+static int get_serial_info(struct tty_struct *tty,
+			   struct serial_struct *ss)
 {
-	struct serial_struct tmp;
-
-	memset(&tmp, 0, sizeof(tmp));
-	tmp.type = PORT_16550A;
-	tmp.line = gb_tty->minor;
-	tmp.xmit_fifo_size = 16;
-	tmp.baud_base = 9600;
-	tmp.close_delay = gb_tty->port.close_delay / 10;
-	tmp.closing_wait =
+	struct gb_tty *gb_tty = tty->driver_data;
+
+	ss->type = PORT_16550A;
+	ss->line = gb_tty->minor;
+	ss->xmit_fifo_size = 16;
+	ss->baud_base = 9600;
+	ss->close_delay = gb_tty->port.close_delay / 10;
+	ss->closing_wait =
 		gb_tty->port.closing_wait == ASYNC_CLOSING_WAIT_NONE ?
 		ASYNC_CLOSING_WAIT_NONE : gb_tty->port.closing_wait / 10;
-
-	if (copy_to_user(info, &tmp, sizeof(tmp)))
-		return -EFAULT;
 	return 0;
 }
 
-static int set_serial_info(struct gb_tty *gb_tty,
-			   struct serial_struct __user *newinfo)
+static int set_serial_info(struct tty_struct *tty,
+			   struct serial_struct *ss)
 {
-	struct serial_struct new_serial;
+	struct gb_tty *gb_tty = tty->driver_data;
 	unsigned int closing_wait;
 	unsigned int close_delay;
 	int retval = 0;
 
-	if (copy_from_user(&new_serial, newinfo, sizeof(new_serial)))
-		return -EFAULT;
-
-	close_delay = new_serial.close_delay * 10;
-	closing_wait = new_serial.closing_wait == ASYNC_CLOSING_WAIT_NONE ?
-			ASYNC_CLOSING_WAIT_NONE : new_serial.closing_wait * 10;
+	close_delay = ss->close_delay * 10;
+	closing_wait = ss->closing_wait == ASYNC_CLOSING_WAIT_NONE ?
+			ASYNC_CLOSING_WAIT_NONE : ss->closing_wait * 10;
 
 	mutex_lock(&gb_tty->port.mutex);
 	if (!capable(CAP_SYS_ADMIN)) {
@@ -728,12 +721,6 @@ static int gb_tty_ioctl(struct tty_struct *tty, unsigned int cmd,
 	struct gb_tty *gb_tty = tty->driver_data;
 
 	switch (cmd) {
-	case TIOCGSERIAL:
-		return get_serial_info(gb_tty,
-				       (struct serial_struct __user *)arg);
-	case TIOCSSERIAL:
-		return set_serial_info(gb_tty,
-				       (struct serial_struct __user *)arg);
 	case TIOCMIWAIT:
 		return wait_serial_change(gb_tty, arg);
 	}
@@ -818,6 +805,8 @@ static const struct tty_operations gb_ops = {
 	.tiocmget =		gb_tty_tiocmget,
 	.tiocmset =		gb_tty_tiocmset,
 	.get_icount =		gb_tty_get_icount,
+	.set_serial =		set_serial_info,
+	.get_serial =		get_serial_info,
 };
 
 static const struct tty_port_operations gb_port_ops = {
-- 
2.23.0

